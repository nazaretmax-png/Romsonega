<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GBA Ultra Translator Pro - Final</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #151b38;
            --bg-card: #1a2142;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border: #2d3651;
            --shadow: rgba(99, 102, 241, 0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0f1629 100%);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 1rem;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            text-align: center;
            padding: 2rem 1rem;
            background: linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%);
            border-radius: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 20px 60px var(--shadow);
        }

        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(to right, #fff, #e2e8f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            font-size: clamp(0.875rem, 2vw, 1rem);
            opacity: 0.9;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: 1.5rem;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .card-title {
            font-size: clamp(1.1rem, 2.5vw, 1.25rem);
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .badge {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        input[type="file"], select, button {
            width: 100%;
            padding: 0.875rem 1rem;
            border-radius: 0.75rem;
            border: 2px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: clamp(0.875rem, 2vw, 1rem);
            transition: all 0.3s;
            cursor: pointer;
        }

        input[type="file"]:hover, select:hover {
            border-color: var(--accent);
            background: var(--bg-card);
        }

        button {
            font-weight: 600;
            border: none;
            background: linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%);
            margin-top: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 15px var(--shadow);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid var(--accent);
            color: var(--accent);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
        }

        .file-info {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            font-size: 0.875rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .preview-container {
            margin-top: 1rem;
            border-radius: 1rem;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--bg-primary);
        }

        .preview-header {
            background: var(--bg-secondary);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .preview-stats {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .preview-box {
            height: clamp(300px, 40vh, 500px);
            overflow-y: auto;
            overflow-x: auto;
        }

        .preview-box::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .preview-box::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        .preview-box::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: clamp(0.75rem, 1.5vw, 0.875rem);
            font-family: 'Fira Code', 'Courier New', monospace;
        }

        thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--bg-card);
        }

        th {
            padding: 1rem 0.75rem;
            text-align: left;
            font-weight: 600;
            color: var(--accent);
            border-bottom: 2px solid var(--border);
        }

        td {
            padding: 0.875rem 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        tbody tr {
            transition: background 0.2s;
        }

        tbody tr:hover {
            background: var(--bg-secondary);
        }

        .hex {
            color: #a78bfa;
            font-weight: 700;
        }

        .text-cell {
            word-break: break-word;
            max-width: 500px;
        }

        .log-box {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1rem;
            height: 150px;
            overflow-y: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .log-box::-webkit-scrollbar {
            width: 6px;
        }

        .log-box::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 3px;
        }

        .log-success { color: var(--success); }
        .log-error { color: var(--danger); }
        .log-warning { color: var(--warning); }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 0.5rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .header {
                padding: 1.5rem 1rem;
                border-radius: 1rem;
            }

            .card {
                padding: 1rem;
            }

            th, td {
                padding: 0.75rem 0.5rem;
            }

            .text-cell {
                max-width: 200px;
            }

            table {
                display: block;
                overflow-x: auto;
            }
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1rem 1.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            max-width: 90vw;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.success { border-left: 4px solid var(--success); }
        .toast.error { border-left: 4px solid var(--danger); }
        .toast.warning { border-left: 4px solid var(--warning); }

        .patch-report {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            border-left: 4px solid var(--success);
        }

        .report-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .report-item:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>üéÆ GBA Ultra Translator Pro</h1>
        <p>Validazione sicura + Filtri estremi</p>
    </div>

    <div class="card">
        <div class="card-title">
            <span>üìÅ</span> Carica ROM
        </div>
        <input type="file" id="romFile" accept=".gba">
        <div class="file-info" id="romInfo">
            ‚è≥ In attesa di un file ROM...
        </div>
    </div>

    <div class="card">
        <div class="card-title">
            <span>üîç</span> Modalit√† Estrazione
            <span class="badge">ULTRA</span>
        </div>
        <select id="extractMode">
            <option value="short">‚öîÔ∏è Mosse/Oggetti (Solo parole complete)</option>
            <option value="dialogs">üí¨ Dialoghi (Solo frasi umane verificate)</option>
        </select>
        <button onclick="smartScan()">
            Avvia Scansione Ultra-Precisa
        </button>
        
        <div class="preview-container">
            <div class="preview-header">
                <div class="preview-stats" id="stats">Nessun dato</div>
                <button class="btn-secondary" onclick="exportTxt()" style="width: auto; padding: 0.5rem 1rem; margin: 0;">
                    üíæ Scarica TXT
                </button>
            </div>
            <div class="preview-box">
                <table>
                    <thead>
                        <tr>
                            <th>Offset</th>
                            <th>Byte</th>
                            <th>Testo Estratto</th>
                        </tr>
                    </thead>
                    <tbody id="resBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="card-title">
            <span>‚ö°</span> Applica Traduzione (Sistema Sicuro)
        </div>
        <input type="file" id="txtFile" accept=".txt">
        <button class="btn-success" onclick="applyPatch()" id="patchBtn">
            Patchare ROM con Validazione
        </button>
        <div id="patchReport"></div>
    </div>

    <div class="log-box" id="log">‚úÖ Sistema pronto. Filtri estremi e validazione sicura attivi...</div>
</div>

<script>
    const charMap = { 0x00: ' ', 0x01: '√Ä', 0x02: '√Å', 0x03: '√Ç', 0x04: '√á', 0x05: '√à', 0x06: '√â', 0x07: '√ä', 0x08: '√ã', 0x09: '√å', 0x0B: '√é', 0x0C: '√è', 0x0D: '√í', 0x0E: '√ì', 0x0F: '√î', 0x10: '≈í', 0x11: '√ô', 0x12: '√ö', 0x13: '√õ', 0x14: '≈∏', 0x15: '√ü', 0x16: '√†', 0x17: '√°', 0x19: '√ß', 0x1A: '√®', 0x1B: '√©', 0x1C: '√™', 0x1D: '√´', 0x1E: '√¨', 0x20: '√Æ', 0x21: '√Ø', 0x22: '√≤', 0x23: '√≥', 0x24: '√¥', 0x25: '≈ì', 0x26: '√π', 0x27: '√∫', 0x28: '√ª', 0x29: '√ø', 0x2D: '&', 0x2E: '+', 0xAB: '!', 0xAC: '?', 0xAD: '.', 0xAE: '-', 0xB0: '...', 0xB8: ',', 0xBB: 'A', 0xBC: 'B', 0xBD: 'C', 0xBE: 'D', 0xBF: 'E', 0xC0: 'F', 0xC1: 'G', 0xC2: 'H', 0xC3: 'I', 0xC4: 'J', 0xC5: 'K', 0xC6: 'L', 0xC7: 'M', 0xC8: 'N', 0xC9: 'O', 0xCA: 'P', 0xCB: 'Q', 0xCC: 'R', 0xCD: 'S', 0xCE: 'T', 0xCF: 'U', 0xD0: 'V', 0xD1: 'W', 0xD2: 'X', 0xD3: 'Y', 0xD4: 'Z', 0xD5: 'a', 0xD6: 'b', 0xD7: 'c', 0xD8: 'd', 0xD9: 'e', 0xDA: 'f', 0xDB: 'g', 0xDC: 'h', 0xDD: 'i', 0xDE: 'j', 0xDF: 'k', 0xE0: 'l', 0xE1: 'm', 0xE2: 'n', 0xE3: 'o', 0xE4: 'p', 0xE5: 'q', 0xE6: 'r', 0xE7: 's', 0xE8: 't', 0xE9: 'u', 0xEA: 'v', 0xEB: 'w', 0xEC: 'x', 0xED: 'y', 0xEE: 'z', 0xFA: '\\l', 0xFB: '\\p', 0xFD: '\\v', 0xFE: '\\n' };
    const invMap = Object.fromEntries(Object.entries(charMap).map(([k,v]) => [v, parseInt(k)]));
    
    const validSyllables = ['TI', 'TA', 'TO', 'TE', 'TU', 'CA', 'CO', 'CHE', 'CHI', 'SA', 'SO', 'SE', 'SI', 'SU', 
                           'LA', 'LE', 'LI', 'LO', 'LU', 'MA', 'ME', 'MI', 'MO', 'MU', 'NA', 'NE', 'NI', 'NO', 
                           'RA', 'RE', 'RI', 'RO', 'RU', 'PA', 'PE', 'PI', 'PO', 'PU', 'BA', 'BE', 'BI', 'BO',
                           'DA', 'DE', 'DI', 'DO', 'DU', 'GI', 'GA', 'GO', 'GU', 'GE', 'FA', 'FI', 'FO', 'FE',
                           'VA', 'VE', 'VI', 'VO', 'VU', 'ZA', 'ZE', 'ZI', 'ZO', 'ZU', 'ZZA', 'ZZO', 'ZZI',
                           'TRA', 'TRE', 'TRI', 'TRO', 'PRE', 'PRA', 'PRO', 'STA', 'STO', 'STI', 'STE',
                           'THE', 'ING', 'ION', 'TER', 'EST', 'FOR', 'TIO', 'ATI', 'ATE', 'ICA', 'ICO',
                           'URA', 'URE', 'ORA', 'ORE', 'ORI', 'ERA', 'ERE', 'ERI', 'ARO', 'ARE', 'ARI',
                           'CHA', 'CHO', 'CHU', 'GHA', 'GHE', 'GHI', 'GHO', 'GLI', 'GNA', 'GNE', 'GNI', 'GNO',
                           'SCA', 'SCE', 'SCI', 'SCO', 'SCU', 'SHA', 'SHE', 'SHI', 'SHO', 'SPE', 'SPI', 'SPO',
                           'QUA', 'QUE', 'QUI', 'QUO'];
    
    const blockedSounds = ['HA', 'HE', 'HI', 'HO', 'HU', 'BA', 'BE', 'BI', 'BO', 'BU', 
                          'RA', 'RE', 'RI', 'RO', 'RU', 'FO', 'FA', 'FU', 'FE', 'FI',
                          'LA', 'LE', 'LI', 'LO', 'LU', 'WA', 'WE', 'WI', 'WO', 'WU',
                          'YA', 'YE', 'YI', 'YO', 'YU', 'ZA', 'ZE', 'ZI', 'ZO', 'ZU',
                          'HAHA', 'HOHO', 'HEHE', 'HIHI', 'BABA', 'BOBO', 'RARA', 'RORO',
                          'WAWA', 'WOWO', 'YAYA', 'YOYO', 'GAGA', 'GOGO', 'CATT', 'MEO',
                          'DU', 'TU', 'GU', 'NU', 'MU', 'SU', 'CU', 'PU'];
    
    const knownWords = ['ITEM', 'BALL', 'MEGA', 'MOVE', 'HOLD', 'BACK', 'EXIT', 'SURF', 'FIRE', 
                       'AQUA', 'ROCK', 'LEAF', 'VOLT', 'BOLT', 'STAR', 'MOON', 'STONE', 'WATER',
                       'GRASS', 'TOXIC', 'STEEL', 'BURN', 'FREEZE', 'SLEEP', 'DRAGON', 'GHOST',
                       'FAIRY', 'FIGHT', 'GROUND', 'FLYING', 'POISON', 'NORMAL', 'PSYCHIC',
                       'SUPER', 'HYPER', 'MAX', 'FULL', 'HEAL', 'CURE', 'FRESH', 'GUARD',
                       'POTION', 'ELIXIR', 'ETHER', 'REVIVE', 'ESCAPE', 'ROPE', 'REPEL',
                       'BADGE', 'CASE', 'BIKE', 'COIN', 'GOOD', 'GREAT', 'ULTRA', 'MASTER',
                       'SAFARI', 'LEVEL', 'LUXURY', 'NEST', 'NET', 'DIVE', 'TIMER', 'REPEAT',
                       'PREMIER', 'DUSK', 'QUICK', 'HEAL', 'ATTACK', 'DEFENSE', 'SPECIAL',
                       'SPEED', 'ACCURACY', 'EVASION', 'CRITICAL'];
    
    let rom = null;
    let scanResults = [];
    let uniqueStrings = new Set();

    const log = (m, type = 'info') => {
        const l = document.getElementById('log');
        const icon = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ñ∂Ô∏è';
        const className = type === 'success' ? 'log-success' : type === 'error' ? 'log-error' : type === 'warning' ? 'log-warning' : '';
        l.innerHTML += `<span class="${className}">${icon} ${m}</span><br>`;
        l.scrollTop = l.scrollHeight;
    };

    const showToast = (msg, type = 'success') => {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = msg;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    };

    document.getElementById('romFile').onchange = function(e) {
        const reader = new FileReader();
        reader.onload = () => {
            rom = new Uint8Array(reader.result);
            const name = e.target.files[0].name;
            document.getElementById('romInfo').innerHTML = `‚úÖ ROM caricata: <strong>${name}</strong> (${(rom.length / 1024 / 1024).toFixed(2)} MB)`;
            log(`ROM "${name}" caricata con successo`, 'success');
            showToast('ROM caricata con successo!', 'success');
        };
        reader.readAsArrayBuffer(this.files[0]);
    };

    function countSyllables(str) {
        str = str.toUpperCase();
        let count = 0;
        for (let syl of validSyllables) {
            let pos = 0;
            while ((pos = str.indexOf(syl, pos)) !== -1) {
                count++;
                pos += syl.length;
            }
        }
        return count;
    }

    function isValidText(str, mode) {
        if (!str || str.length < 3) return false;

        if (mode === 'dialogs') {
            // LUNGHEZZA MINIMA
            if (str.length < 25) return false; // Aumentato da 20 a 25
            
            // DEVE AVERE MARCATORI DI DIALOGO
            if (!str.includes('\\n') && !str.includes('\\p') && !str.includes('\\l')) return false;
            
            // ANTI-RIPETIZIONI PATTERN ULTRA: Blocca pattern ripetuti
            if (/(.{2,4})\1{2,}/i.test(str)) return false;
            if (/(.)\1{3,}/i.test(str)) return false; // 4+ lettere uguali (era 5+)
            
            // ANTI-RIPETIZIONI TRIPLE: "AAA", "RRR", "EEE"
            if (/([A-Z])\1{2,}/i.test(str)) return false;
            
            // ANTI-SEQUENZE ALFABETICHE
            const alphaParts = str.match(/[A-Z]+/gi) || [];
            for (let part of alphaParts) {
                if (part.length >= 5) {
                    let isSequence = true;
                    for (let i = 0; i < part.length - 1; i++) {
                        const diff = part.charCodeAt(i + 1) - part.charCodeAt(i);
                        if (diff !== 1 && diff !== 2) {
                            isSequence = false;
                            break;
                        }
                    }
                    if (isSequence) return false;
                }
            }
            
            // REGOLA SPAZI: Deve avere almeno 4 spazi (era 3)
            const spaceCount = (str.match(/ /g) || []).length;
            if (str.length > 25 && spaceCount < 4) return false;
            
            // ANTI-ENCODING CORROTTO (pi√π restrittivo)
            const accentCount = (str.match(/[√Ä-√ø]/g) || []).length;
            const normalLetters = (str.match(/[A-Za-z]/g) || []).length;
            if (normalLetters > 0 && accentCount > normalLetters * 0.15) return false; // 20% -> 15%
            
            // ANTI-GLITCH PATTERN POTENZIATO
            if (/[√Ä-√ø]{2,}/.test(str)) return false;
            if (/[√ã√É]{2,}/.test(str)) return false;
            if (/√É["\w]/.test(str)) return false; // Blocca pattern "√É + carattere"
            if (/[√Ö']["\w]/.test(str)) return false; // Blocca pattern "√Ö' + carattere"
            if (/[√É‚Ñ¢√É"√É‚Äö√É‚Ä∞√É‚Äπ]/.test(str)) return false; // Blocca questi caratteri corrotti specifici
            
            // DEVE AVERE ALMENO 4 PAROLE VERE (era 3)
            const words = str.split(/[\s\\]/);
            const realWords = words.filter(w => w.length >= 4 && /^[A-Za-z]+$/.test(w) && countSyllables(w) >= 1);
            if (realWords.length < 4) return false;
            
            // ANTI-PATTERN GRAFICI
            if (/[A-Z]{18,}/.test(str)) return false; // 20 -> 18
            
            // DEVE AVERE VOCALI DISTRIBUITE (pi√π restrittivo)
            const vowelCount = (str.match(/[AEIOUaeiou]/g) || []).length;
            if (normalLetters > 0 && vowelCount < normalLetters * 0.30) return false; // 25% -> 30%
            
            // ANTI-CONSONANTI CONSECUTIVE ECCESSIVE
            if (/[BCDFGHJKLMNPQRSTVWXYZ]{5,}/.test(str)) return false;
            
            // BLOCCA STRINGHE CON TROPPE MAIUSCOLE SINGOLE: "B A C D"
            const singleCaps = str.match(/\b[A-Z]\b/g) || [];
            if (singleCaps.length > 3) return false;
            
            return true;
        }

        if (mode === 'short') {
            if (str.length < 4 || str.length > 18) return false;
            if (str !== str.toUpperCase()) return false;
            if (str.includes('\\')) return false;
            if (/  +/.test(str) || str.startsWith(' ') || str.endsWith(' ')) return false;
            if (/[^A-Z0-9 \.\!\?\-']/.test(str)) return false;
            
            const cleanStr = str.replace(/[^A-Z]/g, '');
            if (blockedSounds.includes(cleanStr)) return false;
            if (str.split(' ').some(word => blockedSounds.includes(word))) return false;
            
            if (!/[AEIOU]/.test(str)) return false;
            if (/(.)\1{1,}/.test(str.replace(/[^A-Z]/g, ''))) return false;
            
            const vowels = (str.match(/[AEIOU]/g) || []).length;
            const letters = (str.match(/[A-Z]/g) || []).length;
            if (letters > 0 && vowels < letters * 0.30) return false;
            
            if (/[BCDFGHJKLMNPQRSTVWXYZ]{4,}/.test(str)) return false;
            
            for (let i = 0; i < str.length - 2; i++) {
                const c1 = str.charCodeAt(i);
                const c2 = str.charCodeAt(i + 1);
                const c3 = str.charCodeAt(i + 2);
                if (c2 === c1 + 1 && c3 === c2 + 1) return false;
            }
            
            const syllableCount = countSyllables(str);
            if (syllableCount < 2) {
                if (!knownWords.includes(str.replace(/[^A-Z]/g, ''))) {
                    return false;
                }
            }
            
            const rareLetters = (str.match(/[QXZJKW]/g) || []).length;
            if (rareLetters > letters * 0.4) return false;
            
            if (/^[0-9\.\-\s]+$/.test(str)) return false;
            
            return true;
        }
        return false;
    }

    function smartScan() {
        if(!rom) {
            showToast('Carica prima una ROM!', 'error');
            return;
        }
        
        const mode = document.getElementById('extractMode').value;
        const body = document.getElementById('resBody');
        body.innerHTML = "";
        scanResults = [];
        uniqueStrings.clear();
        
        log(`üîç Scansione ${mode === 'short' ? 'Mosse/Oggetti' : 'Dialoghi'} avviata (filtro ULTRA)...`);

        let i = 0x200000;
        let count = 0;
        let rejected = 0;

        function doScan() {
            let limit = Math.min(i + 0x50000, rom.length);
            for(; i < limit; i++) {
                if(rom[i] >= 0xBB && rom[i] <= 0xD4) {
                    let s = "", j = i;
                    while(j < rom.length && rom[j] !== 0xFF && s.length < 500) {
                        s += charMap[rom[j]] || '';
                        j++;
                    }

                    if(isValidText(s, mode) && !uniqueStrings.has(s)) {
                        uniqueStrings.add(s);
                        
                        const off = "0x" + i.toString(16).toUpperCase();
                        const bytes = j - i;
                        scanResults.push({o: off, t: s, b: bytes});
                        if(count < 200) {
                            body.insertAdjacentHTML('beforeend', 
                                `<tr><td class="hex">${off}</td><td>${bytes}</td><td class="text-cell">${s}</td></tr>`);
                        }
                        count++;
                        i = j;
                    } else {
                        rejected++;
                    }
                }
            }
            
            document.getElementById('stats').textContent = `‚úÖ Valide: ${count} | üö´ Filtrate: ${rejected}`;
            
            if(i < rom.length - 1) {
                requestAnimationFrame(doScan);
            } else {
                log(`‚úÖ Scansione completata: ${count} stringhe valide, ${rejected} filtrate`, 'success');
                showToast(`Trovate ${count} stringhe valide!`, 'success');
            }
        }
        doScan();
    }

    function exportTxt() {
        if(scanResults.length === 0) {
            showToast('Nessun dato da esportare!', 'error');
            return;
        }
        
        let out = "OFFSET | MAX_BYTE | TESTO\n";
        scanResults.forEach(r => out += `${r.o} | ${r.b} | ${r.t}\n`);
        
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([out], {type:'text/plain'}));
        a.download = `Traduzione_${document.getElementById('extractMode').value}_${Date.now()}.txt`;
        a.click();
        
        log(`üì• File esportato: ${scanResults.length} righe`, 'success');
        showToast('File TXT scaricato!', 'success');
    }

    // ============================================================
    // SISTEMA DI PATCHING AVANZATO CON VALIDAZIONE COMPLETA
    // ============================================================

    function calculateByteLength(text) {
        let byteCount = 0;
        for (let i = 0; i < text.length; i++) {
            if (text[i] === '\\' && text[i + 1]) {
                const code = text[i] + text[i + 1];
                if (code === '\\v' && /\d/.test(text[i + 2])) {
                    byteCount += 2; // \v01 = 2 bytes (0xFD + ID)
                    i += 2;
                } else if (invMap[code] !== undefined) {
                    byteCount += 1;
                    i++;
                } else {
                    byteCount += 1;
                }
            } else {
                byteCount += 1;
            }
        }
        byteCount += 1; // Terminatore 0xFF
        return byteCount;
    }

    function textToBytes(text) {
        let bytes = [];
        for (let k = 0; k < text.length; k++) {
            if (text[k] === '\\' && text[k + 1]) {
                let code = text[k] + text[k + 1];
                if (invMap[code] !== undefined) {
                    bytes.push(invMap[code]);
                    k++;
                    continue;
                }
            }
            bytes.push(invMap[text[k]] !== undefined ? invMap[text[k]] : 0x00);
        }
        bytes.push(0xFF); // Terminatore
        return bytes;
    }

    function findFreeSpace(needed) {
        let count = 0;
        for (let i = rom.length - 1; i > 0x800000; i--) {
            if (rom[i] === 0xFF) {
                count++;
            } else {
                count = 0;
            }
            if (count >= needed + 10) {
                return i + 5;
            }
        }
        return -1;
    }

    function createPointer(offset) {
        return new Uint8Array([
            offset & 0xFF,
            (offset >> 8) & 0xFF,
            (offset >> 16) & 0xFF,
            0x08
        ]);
    }

    function repointPointers(oldOffset, newOffset) {
        const oldPtr = createPointer(oldOffset);
        const newPtr = createPointer(newOffset);
        let foundCount = 0;

        for (let i = 0; i < rom.length - 4; i++) {
            if (rom[i] === oldPtr[0] && 
                rom[i + 1] === oldPtr[1] && 
                rom[i + 2] === oldPtr[2] && 
                rom[i + 3] === oldPtr[3]) {
                rom.set(newPtr, i);
                foundCount++;
            }
        }
        return foundCount;
    }

    async function applyPatch() {
        const file = document.getElementById('txtFile').files[0];
        if (!file || !rom) {
            showToast('Manca la ROM o il file TXT!', 'error');
            return;
        }

        const btn = document.getElementById('patchBtn');
        btn.disabled = true;
        btn.textContent = 'Patching in corso...';

        const lines = (await file.text()).split('\n');
        
        let stats = {
            total: 0,
            overwritten: 0,
            repointed: 0,
            failed: 0,
            protected: 0,
            errors: []
        };

        log('‚ö° Avvio patching con validazione sicura...', 'info');

        for (let line of lines) {
            if (!line.includes('|') || line.startsWith('OFFSET')) continue;
            
            const parts = line.split('|').map(s => s.trim());
            if (parts.length < 3) continue;

            const [offsetStr, maxByteStr, text] = parts;
            const oldOffset = parseInt(offsetStr, 16);
            const maxBytes = parseInt(maxByteStr);

            // PROTEZIONE HEADER
            if (oldOffset < 0x200000) {
                stats.protected++;
                log(`‚ö†Ô∏è PROTETTO: ${offsetStr} (area critica)`, 'warning');
                stats.errors.push(`${offsetStr}: Area protetta`);
                continue;
            }

            stats.total++;

            // CALCOLA LUNGHEZZA REALE
            const newBytes = textToBytes(text);
            const newLength = newBytes.length;

            try {
                if (newLength <= maxBytes + 1) {
                    // SOVRASCRIVI IN LOCO
                    rom.set(newBytes, oldOffset);
                    
                    // RIEMPI SPAZIO RIMANENTE CON 0xFF
                    const remaining = (maxBytes + 1) - newLength;
                    if (remaining > 0) {
                        const fillBytes = new Uint8Array(remaining).fill(0xFF);
                        rom.set(fillBytes, oldOffset + newLength);
                    }
                    
                    stats.overwritten++;
                } else {
                    // REPOINTING NECESSARIO
                    const newOffset = findFreeSpace(newLength);
                    
                    if (newOffset === -1) {
                        stats.failed++;
                        log(`‚ùå ERRORE: ${offsetStr} - Spazio insufficiente (${newLength} bytes)`, 'error');
                        stats.errors.push(`${offsetStr}: Spazio insufficiente`);
                        continue;
                    }

                    // Scrivi nel nuovo spazio
                    rom.set(newBytes, newOffset);
                    
                    // Aggiorna puntatori
                    const ptrCount = repointPointers(oldOffset, newOffset);
                    
                    if (ptrCount > 0) {
                        stats.repointed++;
                        log(`üîÄ REPOINT: ${offsetStr} ‚Üí 0x${newOffset.toString(16).toUpperCase()} (${ptrCount} puntatori)`, 'success');
                    } else {
                        log(`‚ö†Ô∏è WARNING: ${offsetStr} repointed ma nessun puntatore trovato`, 'warning');
                        stats.repointed++;
                    }
                }
            } catch (error) {
                stats.failed++;
                log(`‚ùå ERRORE: ${offsetStr} - ${error.message}`, 'error');
                stats.errors.push(`${offsetStr}: ${error.message}`);
            }
        }

        // REPORT FINALE
        const reportHtml = `
            <div class="patch-report">
                <h3 style="color: var(--success); margin-bottom: 1rem;">üìä Report Patching</h3>
                <div class="report-item">
                    <span>Stringhe totali:</span>
                    <strong>${stats.total}</strong>
                </div>
                <div class="report-item">
                    <span>‚úÖ Sovrascritte in loco:</span>
                    <strong style="color: var(--success)">${stats.overwritten}</strong>
                </div>
                <div class="report-item">
                    <span>üîÄ Riposizionate (repoint):</span>
                    <strong style="color: var(--accent)">${stats.repointed}</strong>
                </div>
                <div class="report-item">
                    <span>üõ°Ô∏è Protette (header):</span>
                    <strong style="color: var(--warning)">${stats.protected}</strong>
                </div>
                <div class="report-item">
                    <span>‚ùå Fallite:</span>
                    <strong style="color: var(--danger)">${stats.failed}</strong>
                </div>
            </div>
        `;

        document.getElementById('patchReport').innerHTML = reportHtml;

        log('‚úÖ Patching completato!', 'success');
        log(`üìà Successo: ${stats.overwritten + stats.repointed}/${stats.total}`, 'success');
        
        if (stats.failed > 0) {
            log(`‚ö†Ô∏è ${stats.failed} stringhe fallite per spazio insufficiente`, 'warning');
        }

        // DOWNLOAD ROM PATCHATA
        const blob = new Blob([rom], { type: 'application/octet-stream' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'Pokemon_Tradotto_SAFE.gba';
        a.click();

        showToast('ROM patchata scaricata con successo!', 'success');
        
        btn.disabled = false;
        btn.textContent = 'Patchare ROM con Validazione';
    }
</script>
</body>
</html>

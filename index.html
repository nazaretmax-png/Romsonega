<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>GBA Translator - Surgical Edition</title>
    <style>
        :root { --bg: #0f172a; --card: #1e293b; --accent: #38bdf8; --success: #10b981; --text: #f8fafc; --error: #ef4444; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); color: var(--text); padding: 20px; max-width: 1100px; margin: 0 auto; line-height: 1.5; }
        h1 { text-align: center; color: var(--accent); letter-spacing: 1px; }
        .grid { display: grid; grid-template-columns: 350px 1fr; gap: 20px; }
        .card { background: var(--card); padding: 20px; border-radius: 12px; border: 1px solid #334155; box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        h3 { margin-top: 0; color: #94a3b8; font-size: 1.1em; border-bottom: 1px solid #334155; padding-bottom: 10px; }
        .badge { display: inline-block; padding: 6px 12px; border-radius: 6px; font-weight: bold; font-size: 13px; margin-top: 10px; width: 100%; box-sizing: border-box; text-align: center; }
        .badge.green { background: rgba(16, 185, 129, 0.2); color: var(--success); border: 1px solid var(--success); }
        .badge.red { background: rgba(239, 68, 68, 0.2); color: var(--error); border: 1px solid var(--error); }
        select, input[type="file"] { width: 100%; padding: 10px; background: #0b1120; border: 1px solid #475569; color: white; border-radius: 6px; margin-bottom: 15px; box-sizing: border-box; }
        button { background: var(--accent); color: #0b1120; border: none; padding: 12px; border-radius: 6px; cursor: pointer; width: 100%; font-weight: bold; margin-bottom: 10px; transition: 0.2s; }
        button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        .btn-export { background: transparent; border: 2px solid var(--accent); color: var(--accent); }
        .btn-import { background: var(--success); color: #000; }
        
        .preview-box { background: #000; border-radius: 8px; height: 550px; overflow-y: auto; border: 1px solid #334155; }
        table { width: 100%; border-collapse: collapse; font-family: 'Consolas', monospace; font-size: 13px; }
        th { background: #1e293b; position: sticky; top: 0; padding: 12px; text-align: left; color: var(--accent); }
        td { padding: 8px 12px; border-bottom: 1px solid #1e293b; color: #cbd5e1; }
        .col-offset { color: #818cf8; width: 120px; }
    </style>
</head>
<body>

    <h1>Pok√©mon GBA Translator üéØ <span style="font-size: 0.5em; color:#94a3b8;">Surgical Edition</span></h1>

    <div class="grid">
        <div class="sidebar">
            <div class="card">
                <h3>1. Riconoscimento ROM</h3>
                <input type="file" id="romFile" accept=".gba">
                <div id="gameBadge" class="badge" style="display:none;"></div>
            </div>

            <div class="card">
                <h3>2. Estrazione di Precisione</h3>
                <select id="categorySelect">
                    <option value="moves">‚öîÔ∏è Mosse (Precisione 100%)</option>
                    <option value="items">üéí Oggetti (Precisione 100%)</option>
                    <option value="abilities">üß¨ Abilit√† (Precisione 100%)</option>
                    <option value="dialogs">üí¨ Dialoghi (Filtro Severo Anti-Matrix)</option>
                </select>
                <button onclick="scan()">Scansiona ed Estrai</button>
                <button class="btn-export" onclick="downloadTxt()">Scarica File TXT</button>
            </div>

            <div class="card">
                <h3>3. Applica Traduzione</h3>
                <input type="file" id="importFile" accept=".txt">
                <button class="btn-import" onclick="importAndSave()">Patcha e Salva ROM ITA</button>
            </div>
        </div>

        <div class="main">
            <div class="card" style="padding: 0; overflow: hidden;">
                <div class="preview-box">
                    <table>
                        <thead>
                            <tr><th class="col-offset">Offset (Hex)</th><th>Testo Trovato</th></tr>
                        </thead>
                        <tbody id="resBody">
                            <tr><td colspan="2" style="text-align:center; padding:40px;">Carica la ROM per visualizzare i dati senza errori.</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

<script>
    // Database Strutturale Esatto (Evita il testo Matrix leggendo solo blocchi definiti)
    const GAME_DB = {
        "BPRE": { name: "FireRed (USA)",
            moves: { off: 0x247094, len: 13, count: 354 },
            items: { off: 0x3DB028, len: 14, count: 375 },
            abilities: { off: 0x24F2AC, len: 13, count: 78 }
        },
        "BPEE": { name: "Emerald (USA)",
            moves: { off: 0x31977C, len: 13, count: 354 },
            items: { off: 0x5839A0, len: 14, count: 377 },
            abilities: { off: 0x31C420, len: 13, count: 78 }
        },
        "AXVE": { name: "Ruby (USA)",
            moves: { off: 0x1F8320, len: 13, count: 354 },
            items: { off: 0x3D4294, len: 14, count: 349 },
            abilities: { off: 0x1F995C, len: 13, count: 78 }
        }
    };

    // Mappa Caratteri Pulita
    const charMap = { 0x00: ' ', 0x01: '√Ä', 0x02: '√Å', 0x03: '√Ç', 0x04: '√á', 0x05: '√à', 0x06: '√â', 0x07: '√ä', 0x08: '√ã', 0x09: '√å', 0x0B: '√é', 0x0C: '√è', 0x0D: '√í', 0x0E: '√ì', 0x0F: '√î', 0x10: '≈í', 0x11: '√ô', 0x12: '√ö', 0x13: '√õ', 0x14: '≈∏', 0x15: '√ü', 0x16: '√†', 0x17: '√°', 0x19: '√ß', 0x1A: '√®', 0x1B: '√©', 0x1C: '√™', 0x1D: '√´', 0x1E: '√¨', 0x20: '√Æ', 0x21: '√Ø', 0x22: '√≤', 0x23: '√≥', 0x24: '√¥', 0x25: '≈ì', 0x26: '√π', 0x27: '√∫', 0x28: '√ª', 0x29: '√ø', 0x2D: '&', 0x2E: '+', 0xAB: '!', 0xAC: '?', 0xAD: '.', 0xAE: '-', 0xB0: '...', 0xB8: ',', 0xBB: 'A', 0xBC: 'B', 0xBD: 'C', 0xBE: 'D', 0xBF: 'E', 0xC0: 'F', 0xC1: 'G', 0xC2: 'H', 0xC3: 'I', 0xC4: 'J', 0xC5: 'K', 0xC6: 'L', 0xC7: 'M', 0xC8: 'N', 0xC9: 'O', 0xCA: 'P', 0xCB: 'Q', 0xCC: 'R', 0xCD: 'S', 0xCE: 'T', 0xCF: 'U', 0xD0: 'V', 0xD1: 'W', 0xD2: 'X', 0xD3: 'Y', 0xD4: 'Z', 0xD5: 'a', 0xD6: 'b', 0xD7: 'c', 0xD8: 'd', 0xD9: 'e', 0xDA: 'f', 0xDB: 'g', 0xDC: 'h', 0xDD: 'i', 0xDE: 'j', 0xDF: 'k', 0xE0: 'l', 0xE1: 'm', 0xE2: 'n', 0xE3: 'o', 0xE4: 'p', 0xE5: 'q', 0xE6: 'r', 0xE7: 's', 0xE8: 't', 0xE9: 'u', 0xEA: 'v', 0xEB: 'w', 0xEC: 'x', 0xED: 'y', 0xEE: 'z', 0xFE: '\n' };
    const invMap = Object.fromEntries(Object.entries(charMap).map(([k, v]) => [v, parseInt(k)]));

    let rom = null;
    let detectedGame = null;
    let foundItems = [];

    document.getElementById('romFile').onchange = function(e) {
        const reader = new FileReader();
        reader.onload = () => {
            rom = new Uint8Array(reader.result);
            let id = "";
            for(let i=0xAC; i<0xB0; i++) id += String.fromCharCode(rom[i]);
            
            const badge = document.getElementById('gameBadge');
            badge.style.display = "block";
            if(GAME_DB[id]) {
                detectedGame = GAME_DB[id];
                badge.className = "badge green";
                badge.innerText = "‚úÖ Rilevato: " + detectedGame.name;
            } else {
                detectedGame = null;
                badge.className = "badge red";
                badge.innerText = "‚ùå ROM Sconosciuta (ID: " + id + ")";
            }
        };
        reader.readAsArrayBuffer(this.files[0]);
    };

    function scan() {
        if(!rom) return alert("Per favore, carica la ROM.");
        if(!detectedGame && document.getElementById('categorySelect').value !== 'dialogs') {
            return alert("ROM non supportata in automatico. Usa la modalit√† 'Dialoghi' per scansionare.");
        }

        const cat = document.getElementById('categorySelect').value;
        const body = document.getElementById('resBody');
        body.innerHTML = ""; foundItems = [];

        // MODALITA' CHIRURGICA PER MOSSE, OGGETTI E ABILITA'
        if(cat !== 'dialogs') {
            let table = detectedGame[cat];
            for(let i = 0; i < table.count; i++) {
                let offset = table.off + (i * table.len);
                let str = "";
                // Legge ESATTAMENTE la lunghezza fissa (es. 13 byte)
                for(let j = 0; j < table.len; j++) {
                    let byte = rom[offset + j];
                    if(byte === 0xFF) break; // Termina la stringa se trova FF
                    str += charMap[byte] || ''; 
                }
                
                if(str.trim().length > 0) {
                    const offStr = "0x" + offset.toString(16).toUpperCase();
                    foundItems.push({ o: offStr, t: str, maxLen: table.len });
                    body.innerHTML += `<tr><td class="col-offset">${offStr}</td><td>${str}</td></tr>`;
                }
            }
        } 
        // MODALITA' FILTRO SEVERO PER I DIALOGHI
        else {
            let startOffset = detectedGame ? 0x150000 : 0x100000; // Salta il motore di gioco
            for(let i = startOffset; i < rom.length - 20; i++) {
                if(rom[i] >= 0xBB && rom[i] <= 0xD4) { // Inizia con Maiuscola
                    let str = "";
                    let j = i;
                    let validText = true;
                    
                    while(j < rom.length && rom[j] !== 0xFF && str.length < 300) {
                        let byte = rom[j];
                        // Se incontra un byte di sistema, lo tramuta in spazio per non rompere il testo
                        if(byte >= 0xF7 && byte <= 0xFE) { str += " "; } 
                        // Se il byte NON ESISTE nella mappa, E' CODICE BINARIO. Abortisce la lettura.
                        else if(charMap[byte] === undefined) { validText = false; break; } 
                        else { str += charMap[byte]; }
                        j++;
                    }
                    
                    // Se la stringa √® interamente testuale e lunga almeno 10 lettere, la approva
                    if(validText && str.trim().length >= 10) {
                        const offStr = "0x" + i.toString(16).toUpperCase();
                        foundItems.push({ o: offStr, t: str, maxLen: -1 });
                        body.innerHTML += `<tr><td class="col-offset">${offStr}</td><td>${str}</td></tr>`;
                        i = j; // Salta alla fine
                    }
                }
            }
            if(foundItems.length === 0) body.innerHTML = `<tr><td colspan="2" style="text-align:center;">Nessun dialogo pulito trovato.</td></tr>`;
        }
    }

    function downloadTxt() {
        if(foundItems.length === 0) return alert("Scansiona i dati prima di esportare.");
        let txt = "OFFSET | TESTO_ORIGINALE\n";
        foundItems.forEach(item => { txt += `${item.o} | ${item.t}\n`; });
        const blob = new Blob([txt], {type: 'text/plain'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "Da_Tradurre.txt";
        a.click();
    }

    async function importAndSave() {
        const file = document.getElementById('importFile').files[0];
        if(!file || !rom) return alert("Assicurati di aver caricato la ROM e il File TXT.");
        const text = await file.text();
        const lines = text.split('\n');
        
        let successCount = 0;

        lines.forEach(line => {
            if(!line.includes('|') || line.startsWith('OFFSET')) return;
            const [offStr, content] = line.split('|').map(s => s.trim());
            const offset = parseInt(offStr, 16);
            
            // Trova la lunghezza massima (o tramite la tabella fissa o cercando 0xFF)
            let maxLen = 0;
            let itemDef = foundItems.find(i => i.o === offStr);
            if(itemDef && itemDef.maxLen !== -1) {
                maxLen = itemDef.maxLen - 1; // Lascia 1 byte per 0xFF finale
            } else {
                while(rom[offset + maxLen] !== 0xFF) maxLen++;
            }
            
            let bytes = [];
            for(let char of content) {
                bytes.push(invMap[char] || 0x00); // 0x00 √® lo spazio
            }

            // Scrive i nuovi byte troncando se superano il limite e riempie il vuoto con 0xFF (standard GBA)
            for(let i = 0; i <= maxLen; i++) {
                rom[offset + i] = (i < bytes.length) ? bytes[i] : 0xFF; 
            }
            // Mette il terminatore alla fine
            rom[offset + (bytes.length > maxLen ? maxLen : bytes.length)] = 0xFF;
            
            successCount++;
        });
        
        const blob = new Blob([rom], {type: 'application/octet-stream'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "ROM_PATCHATA_ITA.gba";
        a.click();
        alert(`Finito! Patchate ${successCount} stringhe con successo senza corrompere i dati.`);
    }
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GBA Translator COMPLETE - Sistema Intelligente Auto</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg: #0a0e1a;
            --card: #12182a;
            --accent: #6366f1;
            --text: #e2e8f0;
            --text-dim: #94a3b8;
            --border: #1f2937;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0.75rem;
        }

        /* Header minimalista */
        .header {
            text-align: center;
            padding: 1.5rem 0.75rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--accent);
        }

        .header h1 {
            font-size: clamp(1.25rem, 5vw, 1.75rem);
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }

        .header p {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        /* Sezioni compatte */
        .section {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.875rem;
            margin-bottom: 0.75rem;
        }

        .section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.625rem;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        /* Input minimalisti */
        input[type="file"], select, button {
            width: 100%;
            padding: 0.625rem 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-size: 0.875rem;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: auto;
            cursor: pointer;
            accent-color: var(--accent);
        }

        label {
            user-select: none;
        }

        button {
            font-weight: 600;
            background: var(--accent);
            border: none;
            margin-top: 0.5rem;
            transition: opacity 0.2s;
        }

        button:hover:not(:disabled) { opacity: 0.85; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .btn-success { background: var(--success); }

        /* Info compatta */
        .info {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg);
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .info.saved {
            border-left: 3px solid var(--success);
            color: var(--success);
        }

        /* Preview box minimalista */
        .preview {
            margin-top: 0.625rem;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            overflow: hidden;
            background: var(--bg);
        }

        .preview-header {
            background: var(--card);
            padding: 0.5rem 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
        }

        .preview-box {
            height: clamp(250px, 35vh, 400px);
            overflow: auto;
        }

        .preview-box::-webkit-scrollbar { width: 6px; height: 6px; }
        .preview-box::-webkit-scrollbar-track { background: var(--bg); }
        .preview-box::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }

        /* Tabella compatta */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }

        th {
            position: sticky;
            top: 0;
            background: var(--card);
            padding: 0.5rem;
            text-align: left;
            font-weight: 600;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
        }

        td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        tr:hover { background: var(--card); }

        .hex { color: #a78bfa; font-weight: 600; }
        .text-cell { word-break: break-word; }

        /* Progress bar minimalista */
        .progress {
            margin-top: 0.5rem;
            display: none;
        }
        .progress.active { display: block; }

        .progress-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }

        .progress-bar {
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            transition: width 0.2s;
        }

        .progress-status {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 0.25rem;
            font-style: italic;
        }

        /* Log minimalista */
        .log {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.5rem;
            height: 80px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            color: var(--text-dim);
            line-height: 1.4;
        }

        .log::-webkit-scrollbar { width: 4px; }
        .log::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 2px; }

        .log-success { color: var(--success); }
        .log-error { color: var(--danger); }
        .log-warning { color: var(--warning); }

        /* Report compatto */
        .report {
            margin-top: 0.625rem;
            padding: 0.75rem;
            background: var(--bg);
            border-radius: 0.375rem;
            border-left: 3px solid var(--success);
            font-size: 0.75rem;
        }

        .report-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        /* Toast minimalista */
        .toast {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.75rem 1rem;
            font-size: 0.8rem;
            max-width: 90vw;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 1000;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.success { border-left: 3px solid var(--success); }
        .toast.error { border-left: 3px solid var(--danger); }
        .toast.warning { border-left: 3px solid var(--warning); }

        /* Dialog Resume */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .modal.active { display: flex; }

        .modal-content {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1.25rem;
            max-width: 400px;
            margin: 1rem;
        }

        .modal-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.75rem;
        }

        .modal-text {
            font-size: 0.875rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.5rem;
        }

        .modal-actions button {
            margin: 0;
            flex: 1;
        }

        /* Mobile ottimizzato */
        @media (max-width: 640px) {
            .container { padding: 0.5rem; }
            .section { padding: 0.625rem; }
            th, td { padding: 0.375rem; font-size: 0.7rem; }
            .text-cell { max-width: 150px; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>üöÄ GBA Translator COMPLETE</h1>
        <p style="text-align:center;color:var(--text-dim);font-size:0.85rem;margin-top:0.5rem">
            Sistema Intelligente con Auto-Rilevamento Tabelle | Espansione ROM | Memoria Persistente
        </p>
        <p>Filtri ultra + Autosave intelligente</p>
    </div>

    <!-- ROM -->
    <div class="section">
        <div class="section-title">üìÅ ROM</div>
        <input type="file" id="romFile" accept=".gba">
        <div class="info" id="romInfo">‚è≥ Carica un file .gba</div>
        <button onclick="downloadROM()" id="downloadBtn" style="margin-top:0.5rem" disabled>‚¨áÔ∏è Scarica ROM Patchata</button>
        <button onclick="fullReset()" style="margin-top:0.5rem;background:var(--danger);font-size:0.75rem">üóëÔ∏è Reset Completo (Memoria + Cache)</button>
    </div>

    <!-- Scansione -->
    <div class="section">
        <div class="section-title">üîç Estrazione</div>
        <select id="extractMode">
            <option value="short">‚öîÔ∏è Mosse/Oggetti (parole singole)</option>
            <option value="dialogs">üí¨ Dialoghi (filtro medio)</option>
            <option value="all">üåê TUTTO il testo (nessun filtro)</option>
        </select>
        <label style="display:flex;align-items:center;gap:0.5rem;margin-top:0.5rem;font-size:0.8rem;cursor:pointer">
            <input type="checkbox" id="englishOnly" style="width:auto">
            <span>Estrai solo testo inglese (üá¨üáß rilevamento automatico)</span>
        </label>
        <div id="repointMemory" style="display:none;font-size:0.7rem;color:var(--accent);margin-top:0.5rem;padding:0.5rem;background:var(--bg);border-radius:0.25rem;border-left:2px solid var(--accent)">
            üß† Memoria: <strong id="repointCount">0</strong> offset repointed salvati
            <button onclick="clearRepointMemory()" style="margin-left:0.5rem;padding:0.25rem 0.5rem;font-size:0.65rem;width:auto;background:var(--danger)">
                üóëÔ∏è Cancella memoria
            </button>
        </div>
        <button onclick="scan()">Scansiona ROM</button>
        
        <div class="progress" id="scanProgress">
            <div class="progress-info">
                <span>Scansione...</span>
                <span id="scanPct">0%</span>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="scanFill"></div></div>
            <div class="progress-status" id="scanStatus"></div>
        </div>
        
        <div class="preview">
            <div class="preview-header">
                <span id="stats">Nessun dato</span>
                <button class="btn-outline" onclick="exportTxt()" style="width:auto;padding:0.375rem 0.75rem;margin:0;font-size:0.7rem">üíæ TXT</button>
            </div>
            <div class="preview-box">
                <table>
                    <thead><tr><th>Offset</th><th>Byte</th><th>Testo</th></tr></thead>
                    <tbody id="resBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Patch -->
    <div class="section">
        <div class="section-title">‚ö° Traduzione</div>
        <input type="file" id="txtFile" accept=".txt">
        <label style="display:flex;align-items:center;gap:0.5rem;margin-top:0.5rem;font-size:0.75rem;cursor:pointer">
            <input type="checkbox" id="forceOverwrite" style="width:auto">
            <span style="color:var(--warning)">‚ö†Ô∏è Forza sovrascrivi (tronca se troppo lungo)</span>
        </label>
        <label style="display:flex;align-items:center;gap:0.5rem;margin-top:0.5rem;font-size:0.75rem;cursor:pointer">
            <input type="checkbox" id="intelligentTables" checked style="width:auto">
            <span style="color:var(--accent)">üß† Sistema Intelligente Tabelle (AUTO)</span>
        </label>
        <button class="btn-success" onclick="patch()" id="patchBtn">Applica Patch</button>
        
        <div class="progress" id="patchProgress">
            <div class="progress-info">
                <span>Patching...</span>
                <span id="patchPct">0%</span>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="patchFill"></div></div>
            <div class="progress-status" id="patchStatus"></div>
        </div>
        
        <div id="patchReport"></div>
    </div>

    <!-- Log -->
    <div class="log" id="log">‚úÖ Sistema pronto</div>
</div>

<!-- Modal Resume -->
<div class="modal" id="resumeModal">
    <div class="modal-content">
        <div class="modal-title">üîÑ Riprendere patch automaticamente?</div>
        <div class="modal-text" id="resumeText"></div>
        <div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:1rem;padding:0.5rem;background:var(--bg);border-radius:0.25rem;border-left:2px solid var(--accent)">
            ‚úÖ ROM e file TXT gi√† salvati in memoria<br>
            ‚úÖ Stato patch preservato<br>
            ‚úÖ Click "Riprendi" per continuare automaticamente
        </div>
        <div class="modal-actions">
            <button class="btn-outline" onclick="clearResume()">Ricomincia da zero</button>
            <button onclick="resumePatch()">‚ñ∂Ô∏è Riprendi patch</button>
        </div>
    </div>
</div>

<script>
    const charMap = { 0x00: ' ', 0x01: '√Ä', 0x02: '√Å', 0x03: '√Ç', 0x04: '√á', 0x05: '√à', 0x06: '√â', 0x07: '√ä', 0x08: '√ã', 0x09: '√å', 0x0B: '√é', 0x0C: '√è', 0x0D: '√í', 0x0E: '√ì', 0x0F: '√î', 0x10: '≈í', 0x11: '√ô', 0x12: '√ö', 0x13: '√õ', 0x14: '≈∏', 0x15: '√ü', 0x16: '√†', 0x17: '√°', 0x19: '√ß', 0x1A: '√®', 0x1B: '√©', 0x1C: '√™', 0x1D: '√´', 0x1E: '√¨', 0x20: '√Æ', 0x21: '√Ø', 0x22: '√≤', 0x23: '√≥', 0x24: '√¥', 0x25: '≈ì', 0x26: '√π', 0x27: '√∫', 0x28: '√ª', 0x29: '√ø', 0x2D: '&', 0x2E: '+', 0xAB: '!', 0xAC: '?', 0xAD: '.', 0xAE: '-', 0xB0: '...', 0xB8: ',', 0xBB: 'A', 0xBC: 'B', 0xBD: 'C', 0xBE: 'D', 0xBF: 'E', 0xC0: 'F', 0xC1: 'G', 0xC2: 'H', 0xC3: 'I', 0xC4: 'J', 0xC5: 'K', 0xC6: 'L', 0xC7: 'M', 0xC8: 'N', 0xC9: 'O', 0xCA: 'P', 0xCB: 'Q', 0xCC: 'R', 0xCD: 'S', 0xCE: 'T', 0xCF: 'U', 0xD0: 'V', 0xD1: 'W', 0xD2: 'X', 0xD3: 'Y', 0xD4: 'Z', 0xD5: 'a', 0xD6: 'b', 0xD7: 'c', 0xD8: 'd', 0xD9: 'e', 0xDA: 'f', 0xDB: 'g', 0xDC: 'h', 0xDD: 'i', 0xDE: 'j', 0xDF: 'k', 0xE0: 'l', 0xE1: 'm', 0xE2: 'n', 0xE3: 'o', 0xE4: 'p', 0xE5: 'q', 0xE6: 'r', 0xE7: 's', 0xE8: 't', 0xE9: 'u', 0xEA: 'v', 0xEB: 'w', 0xEC: 'x', 0xED: 'y', 0xEE: 'z', 0xFA: '\\l', 0xFB: '\\p', 0xFD: '\\v', 0xFE: '\\n' };
    const invMap = Object.fromEntries(Object.entries(charMap).map(([k,v]) => [v, parseInt(k)]));
    
    const validSyllables = ['TI','TA','TO','TE','TU','CA','CO','CHE','CHI','SA','SO','SE','SI','SU','LA','LE','LI','LO','LU','MA','ME','MI','MO','MU','NA','NE','NI','NO','RA','RE','RI','RO','RU','PA','PE','PI','PO','PU','BA','BE','BI','BO','DA','DE','DI','DO','DU','GI','GA','GO','GU','GE','FA','FI','FO','FE','VA','VE','VI','VO','VU','ZA','ZE','ZI','ZO','ZU','ZZA','ZZO','ZZI','TRA','TRE','TRI','TRO','PRE','PRA','PRO','STA','STO','STI','STE','THE','ING','ION','TER','EST','FOR','TIO','ATI','ATE','ICA','ICO','URA','URE','ORA','ORE','ORI','ERA','ERE','ERI','ARO','ARE','ARI','CHA','CHO','CHU','GHA','GHE','GHI','GHO','GLI','GNA','GNE','GNI','GNO','SCA','SCE','SCI','SCO','SCU','SHA','SHE','SHI','SHO','SPE','SPI','SPO','QUA','QUE','QUI','QUO'];
    
    const blockedSounds = ['HA','HE','HI','HO','HU','BA','BE','BI','BO','BU','RA','RE','RI','RO','RU','FO','FA','FU','FE','FI','LA','LE','LI','LO','LU','WA','WE','WI','WO','WU','YA','YE','YI','YO','YU','ZA','ZE','ZI','ZO','ZU','HAHA','HOHO','HEHE','HIHI','BABA','BOBO','RARA','RORO','WAWA','WOWO','YAYA','YOYO','GAGA','GOGO','CATT','MEO','DU','TU','GU','NU','MU','SU','CU','PU'];
    
    const knownWords = ['ITEM','BALL','MEGA','MOVE','HOLD','BACK','EXIT','SURF','FIRE','AQUA','ROCK','LEAF','VOLT','BOLT','STAR','MOON','STONE','WATER','GRASS','TOXIC','STEEL','BURN','FREEZE','SLEEP','DRAGON','GHOST','FAIRY','FIGHT','GROUND','FLYING','POISON','NORMAL','PSYCHIC','SUPER','HYPER','MAX','FULL','HEAL','CURE','FRESH','GUARD','POTION','ELIXIR','ETHER','REVIVE','ESCAPE','ROPE','REPEL','BADGE','CASE','BIKE','COIN','GOOD','GREAT','ULTRA','MASTER','SAFARI','LEVEL','LUXURY','NEST','NET','DIVE','TIMER','REPEAT','PREMIER','DUSK','QUICK','ATTACK','DEFENSE','SPECIAL','SPEED','ACCURACY','EVASION','CRITICAL'];
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // RILEVAMENTO LINGUA AVANZATO
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Parole SICURAMENTE inglesi (comuni + GBA/Pokemon)
    const ENGLISH_WORDS = new Set([
        // Comuni
        'THE','AND','OR','IS','ARE','WAS','WERE','BE','BEEN','BEING','HAVE','HAS','HAD',
        'DO','DOES','DID','WILL','WOULD','SHOULD','CAN','COULD','MAY','MIGHT','MUST',
        'YOU','YOUR','YOURS','HE','SHE','IT','WE','THEY','THEM','THEIR','THIS','THAT',
        'THESE','THOSE','WHAT','WHO','WHERE','WHEN','WHY','HOW','MY','ME','I','HIM','HER','US','OUR',
        'GET','GOT','GIVE','GAVE','TAKE','TOOK','MAKE','MADE','GO','WENT','COME','CAME',
        'KNOW','KNEW','THINK','THOUGHT','SEE','SAW','LOOK','USE','USED','FIND','FOUND',
        'WANT','NEED','TRY','ASK','WORK','CALL','KEEP','LET','PUT','MEAN','LEAVE','LEFT','HOLD','HELD',
        // GBA/Pokemon
        'POKEMON','BATTLE','FIGHT','ATTACK','LEVEL','TEAM','PLAYER','TRAINER',
        'MOVE','ITEM','BAG','MENU','SAVE','LOAD','NEW','GAME','START','SELECT','CANCEL',
        'YES','NO','OK','BACK','NEXT','CONTINUE','HP','PP','TYPE','POWER','SPEED','DEFENSE','SPECIAL',
        'WILD','GYM','LEADER','CHAMPION','BADGE','CATCH','CAUGHT','RUN','FLEE','WIN','WON','LOSE','LOST',
        'BOY','GIRL','MAN','WOMAN','LADY','MISS','MR','YOUNG','OLD','ELITE','FOUR',
        'COUPLE','TWIN','TWINS','BROTHER','SISTER','SIS','BRO','AND','AQUA','MAGMA','ROCKET',
        'COOL','BEAUTY','CUTE','SMART','TOUGH','CONTEST','POTION','BALL','BERRY','MAIL',
        'KEY','ROD','BIKE','COIN','TLE','AROMA'
    ]);
    
    // Parole SICURAMENTE italiane
    const ITALIAN_WORDS = new Set([
        'IL','LO','LA','GLI','LE','UN','UNO','UNA','DEL','DELLA','DELLO','DEGLI','DELLE',
        'DAL','DALLA','AL','ALLO','ALLA','AGLI','ALLE','NEL','NELLO','NELLA','NEGLI','NELLE',
        'CHE','CHI','COME','QUANDO','DOVE','PERCHE','PERCH√â','SONO','SEI','SIAMO','SIETE',
        'ERA','ERANO','STATO','STATA','STATI','HO','HAI','HA','HANNO','AVEVA','AVEVANO',
        'QUESTO','QUESTA','QUESTI','QUESTE','QUELLO','QUELLA','QUELLI','QUELLE',
        'MIO','MIA','MIEI','TUO','TUA','SUOI','SUA','NOSTRO','NOSTRA','VOSTRO','VOSTRA',
        'FARE','FATTO','FAI','FA','FANNO','DIRE','DETTO','DICO','DICE','DICONO',
        'ANDARE','ANDATO','VADO','VAI','VA','ANDIAMO','ANDATE','VANNO',
        'MOLTO','POCO','TANTO','TROPPO','PIU','MENO','ANCHE','ANCORA',
        'POKEMON','LOTTA','BATTAGLIA','ATTACCO','LIVELLO','SQUADRA','ALLENATORE',
        'MOSSA','OGGETTO','ZAINO','SALVA','CARICA','NUOVO','GIOCO','INIZIA',
        'SELEZIONA','ANNULLA','SI','S√å','INDIETRO','AVANTI','CONTINUA',
        'TIPO','POTENZA','VELOCITA','VELOCIT√Ä','DIFESA','SELVAGGIO',
        'PALESTRA','CAPO','CAMPIONE','MEDAGLIA','CATTURA','FUGGI','VINCI','PERDI',
        'RAGAZZO','RAGAZZA','UOMO','DONNA','SIGNORA','SIGNORINA','GIOVANE','VECCHIO',
        'POZIONE','PALLA','BACCA','POSTA','CHIAVE','CANNA','BICI','MONETA','DI','DA'
    ]);
    
    // Pattern italiano: accenti, gl/gn/sc + vocale, terminazioni -zione/-aggio
    const ITALIAN_PATTERNS = [
        /[√†√®√©√¨√≤√π]/i,           // Accenti italiani
        /\b(gl|gn|sc)[ie√®]/i,  // GL, GN, SC + vocale
        /zione\b/i,            // -zione
        /aggio\b/i,            // -aggio  
    ];
    
    // Pattern inglese: th/sh/ch/wh, terminazioni -ing/-tion/-ly/-ed
    const ENGLISH_PATTERNS = [
        /\b(th|sh|wh)[aeiou]/i,  // TH, SH, WH + vocale
        /ing\b/i,                 // -ing
        /tion\b/i,                // -tion
        /ness\b/i,                // -ness
        /ly\b/i,                  // -ly (VERY, ONLY, etc.)
    ];

    function isEnglish(text) {
        if (!text || text.length < 2) return true;
        
        const upper = text.toUpperCase().trim();
        const words = upper.split(/\s+/).filter(w => w.length >= 2);
        
        // 1. BLOCCA se ha accenti italiani o pattern italiani
        for (const pattern of ITALIAN_PATTERNS) {
            if (pattern.test(text)) {
                return false; // Sicuramente italiano
            }
        }
        
        // 2. CONTROLLA parole italiane sicure
        let italianCount = 0;
        for (const word of words) {
            if (ITALIAN_WORDS.has(word)) {
                italianCount++;
            }
        }
        if (italianCount > words.length * 0.3) {
            return false; // >30% parole italiane
        }
        
        // 3. CONTROLLA parole inglesi sicure
        let englishCount = 0;
        for (const word of words) {
            if (ENGLISH_WORDS.has(word)) {
                englishCount++;
            }
        }
        if (englishCount > 0) {
            return true; // Ha almeno una parola inglese sicura
        }
        
        // 4. CONTROLLA pattern inglesi
        for (const pattern of ENGLISH_PATTERNS) {
            if (pattern.test(text)) {
                return true; // Ha pattern inglese
            }
        }
        
        // 5. EURISTICHE finali
        const hasY = /y/i.test(text);
        const hasW = /w/i.test(text);
        const hasQ_NoU = /q(?!u)/i.test(text);
        
        if (hasQ_NoU) return false; // Q senza U = non inglese
        if (hasY || hasW) return true; // Y/W comuni in inglese
        
        // Default: assume inglese se ambiguo
        return true;
    }
    
    let rom = null;
    let scanResults = [];
    let uniqueStrings = new Set();
    let repointedOffsets = new Set(); // Traccia offset repointed per skipparli in scansione
    let romExpansions = 0; // Conta quante volte espandiamo la ROM

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AUTOSAVE SYSTEM con IndexedDB
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const AUTOSAVE_KEY = 'gba_patch_state';
    const AUTOSAVE_INTERVAL = 10;
    const DB_NAME = 'GBATranslatorDB';
    const DB_VERSION = 1;
    let db = null;

    // Inizializza IndexedDB
    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                db = request.result;
                resolve(db);
            };
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('files')) {
                    db.createObjectStore('files', { keyPath: 'id' });
                }
            };
        });
    }

    // Salva ROM in IndexedDB
    async function saveROM(romData) {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readwrite');
            const store = tx.objectStore('files');
            const request = store.put({ id: 'rom', data: romData, timestamp: Date.now() });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    // Carica ROM da IndexedDB
    async function loadROM() {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readonly');
            const store = tx.objectStore('files');
            const request = store.get('rom');
            request.onsuccess = () => resolve(request.result?.data || null);
            request.onerror = () => reject(request.error);
        });
    }

    // Salva file TXT in IndexedDB
    async function saveTxtContent(content) {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readwrite');
            const store = tx.objectStore('files');
            const request = store.put({ id: 'txt', data: content, timestamp: Date.now() });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    // Carica file TXT da IndexedDB
    async function loadTxtContent() {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readonly');
            const store = tx.objectStore('files');
            const request = store.get('txt');
            request.onsuccess = () => resolve(request.result?.data || null);
            request.onerror = () => reject(request.error);
        });
    }

    // Salva stato patch
    function saveState(idx, stats, lines) {
        const state = {
            timestamp: Date.now(),
            lastIndex: idx,
            stats: stats,
            totalLines: lines.length,
            repointedOffsets: Array.from(repointedOffsets) // Salva offset repointed
        };
        localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(state));
    }

    // Carica stato patch
    function loadState() {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (saved) {
            const state = JSON.parse(saved);
            // Ripristina offset repointed
            if (state.repointedOffsets) {
                repointedOffsets = new Set(state.repointedOffsets);
            }
            return state;
        }
        return null;
    }

    // Cancella tutto
    async function clearState() {
        localStorage.removeItem(AUTOSAVE_KEY);
        repointedOffsets.clear(); // Reset memoria repoint
        if (db) {
            const tx = db.transaction(['files'], 'readwrite');
            const store = tx.objectStore('files');
            store.delete('rom');
            store.delete('txt');
        }
    }

    // Check resume al caricamento
    window.addEventListener('load', async () => {
        await initDB();
        const state = loadState();
        if (state && Date.now() - state.timestamp < 24*60*60*1000) {
            const elapsed = Math.floor((Date.now() - state.timestamp) / 60000);
            document.getElementById('resumeText').textContent = 
                `Trovato salvataggio da ${elapsed < 1 ? '<1' : elapsed} minuti fa.\nProcessate ${state.lastIndex}/${state.totalLines} stringhe.\n\nROM e file TXT salvati automaticamente.`;
            document.getElementById('resumeModal').classList.add('active');
        }
        
        // Aggiorna UI memoria repoint
        updateRepointMemoryUI();
    });

    // Cancella e ricomincia
    async function clearResume() {
        await clearState();
        document.getElementById('resumeModal').classList.remove('active');
        toast('Stato cancellato', 'success');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UTILITIES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const log = (m, type = 'info') => {
        const l = document.getElementById('log');
        const cls = type === 'success' ? 'log-success' : type === 'error' ? 'log-error' : type === 'warning' ? 'log-warning' : '';
        l.innerHTML += `<span class="${cls}">${m}</span><br>`;
        l.scrollTop = l.scrollHeight;
    };

    const toast = (msg, type = 'success') => {
        const t = document.createElement('div');
        t.className = `toast ${type}`;
        t.textContent = msg;
        document.body.appendChild(t);
        setTimeout(() => t.remove(), 2500);
    };

    document.getElementById('romFile').onchange = function(e) {
        const reader = new FileReader();
        reader.onload = async () => {
            rom = new Uint8Array(reader.result);
            const mb = (rom.length / 1024 / 1024).toFixed(1);
            const info = document.getElementById('romInfo');
            info.innerHTML = `‚úÖ ${e.target.files[0].name} (${mb} MB)`;
            document.getElementById('downloadBtn').disabled = false; // Abilita download
            
            // RESET MEMORIA quando carica nuova ROM
            const hadMemory = repointedOffsets.size > 0;
            repointedOffsets.clear();
            updateRepointMemoryUI();
            
            if (hadMemory) {
                log('üóëÔ∏è Memoria precedente cancellata (nuova ROM rilevata)', 'warning');
                toast('‚ö†Ô∏è Memoria resettata - Nuova ROM', 'warning');
            }
            
            log('ROM caricata', 'success');
            
            // Salva ROM in IndexedDB per resume automatico
            try {
                await saveROM(rom);
                info.innerHTML = `‚úÖ ${e.target.files[0].name} (${mb} MB) üíæ <span style="color:var(--success)">Salvata per resume</span>`;
                info.classList.add('saved');
                log('ROM salvata per resume automatico', 'success');
            } catch(err) {
                log('Avviso: ROM non salvata (spazio disco pieno?)', 'warning');
            }
        };
        reader.readAsArrayBuffer(this.files[0]);
    };

    function countSyllables(str) {
        str = str.toUpperCase();
        let count = 0;
        for (let syl of validSyllables) {
            let pos = 0;
            while ((pos = str.indexOf(syl, pos)) !== -1) {
                count++;
                pos += syl.length;
            }
        }
        return count;
    }

    function isValidText(str, mode) {
        if (!str || str.length < 3) return false;

        // MODALIT√Ä ALL - Accetta quasi tutto
        if (mode === 'all') {
            // Solo filtri anti-garbage estremi
            if (str.length < 3) return false;
            
            // Deve avere almeno QUALCHE lettera
            if (!/[A-Za-z]/.test(str)) return false;
            
            // Anti-encoding corrotto estremo
            const accentCount = (str.match(/[√Ä-√ø]/g) || []).length;
            const normalLetters = (str.match(/[A-Za-z]/g) || []).length;
            if (normalLetters > 0 && accentCount > normalLetters * 0.5) return false;
            
            // Anti-pattern grafici totali
            if (/[√Ä-√ø]{3,}/.test(str)) return false;
            if (/(.)\1{6,}/.test(str)) return false; // 7+ ripetizioni
            
            return true;
        }

        // DIALOGHI - FILTRO LEGGERO
        if (mode === 'dialogs') {
            // Lunghezza minima RIDOTTA
            if (str.length < 10) return false; // Era 15
            
            // Accetta dialoghi CON o SENZA marcatori se abbastanza lunghi
            const hasMarkers = str.includes('\\n') || str.includes('\\p') || str.includes('\\l');
            if (!hasMarkers && str.length < 20) return false;
            
            // Anti-ripetizioni base
            if (/(.)\1{5,}/.test(str)) return false; // 6+ lettere uguali
            
            // Anti-encoding corrotto (pi√π permissivo)
            const accentCount = (str.match(/[√Ä-√ø]/g) || []).length;
            const normalLetters = (str.match(/[A-Za-z]/g) || []).length;
            if (normalLetters > 0 && accentCount > normalLetters * 0.25) return false; // Era 0.15
            
            // Anti-glitch pattern base
            if (/[√Ä-√ø]{3,}/.test(str)) return false;
            if (/[√ã√É]{2,}/.test(str)) return false;
            
            // Vocali minime
            const vowelCount = (str.match(/[AEIOUaeiou]/g) || []).length;
            if (normalLetters > 5 && vowelCount < normalLetters * 0.20) return false; // Era 0.25
            
            // Almeno 1 parola di 3+ lettere
            const words = str.split(/[\s\\,!?.;:\-]/);
            const hasWord = words.some(w => /^[A-Za-z]{3,}$/.test(w));
            if (!hasWord) return false;
            
            return true;
        }

        // MOSSE/OGGETTI - Filtro stringente
        if (mode === 'short') {
            if (str.length < 3 || str.length > 20) return false; // Era max 18
            if (str !== str.toUpperCase()) return false;
            if (str.includes('\\')) return false;
            if (/  +/.test(str) || str.startsWith(' ') || str.endsWith(' ')) return false;
            if (/[^A-Z0-9 \.\!\?\-']/.test(str)) return false;
            
            const cleanStr = str.replace(/[^A-Z]/g, '');
            if (blockedSounds.includes(cleanStr)) return false;
            if (str.split(' ').some(word => blockedSounds.includes(word))) return false;
            
            if (!/[AEIOU]/.test(str)) return false;
            if (/(.)\1{1,}/.test(str.replace(/[^A-Z]/g, ''))) return false;
            
            const vowels = (str.match(/[AEIOU]/g) || []).length;
            const letters = (str.match(/[A-Z]/g) || []).length;
            if (letters > 0 && vowels < letters * 0.25) return false; // Era 0.30
            
            if (/[BCDFGHJKLMNPQRSTVWXYZ]{4,}/.test(str)) return false;
            
            for (let i = 0; i < str.length - 2; i++) {
                const c1 = str.charCodeAt(i);
                const c2 = str.charCodeAt(i + 1);
                const c3 = str.charCodeAt(i + 2);
                if (c2 === c1 + 1 && c3 === c2 + 1) return false;
            }
            
            const syllableCount = countSyllables(str);
            if (syllableCount < 1) { // Era 2
                if (!knownWords.includes(str.replace(/[^A-Z]/g, ''))) return false;
            }
            
            const rareLetters = (str.match(/[QXZJKW]/g) || []).length;
            if (rareLetters > letters * 0.4) return false;
            if (/^[0-9\.\-\s]+$/.test(str)) return false;
            
            return true;
        }
        return false;
    }

    // Aggiorna UI memoria repoint
    function updateRepointMemoryUI() {
        const memoryDiv = document.getElementById('repointMemory');
        const countSpan = document.getElementById('repointCount');
        
        if (repointedOffsets.size > 0) {
            memoryDiv.style.display = 'block';
            countSpan.textContent = repointedOffsets.size;
        } else {
            memoryDiv.style.display = 'none';
        }
    }

    // Cancella memoria repoint
    function clearRepointMemory() {
        if (confirm(`Cancellare ${repointedOffsets.size} offset dalla memoria?\n\nQuesti offset non verranno pi√π skippati durante la scansione.`)) {
            repointedOffsets.clear();
            updateRepointMemoryUI();
            toast('Memoria cancellata', 'success');
            log('üóëÔ∏è Memoria repoint cancellata', 'info');
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SCAN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function scan() {
        if(!rom) return toast('Carica ROM prima!', 'error');
        
        // WARNING se memoria presente (potrebbe essere da ROM diversa)
        if (repointedOffsets.size > 0) {
            const useMemory = window.confirm(
                '‚ö†Ô∏è MEMORIA ESISTENTE RILEVATA\n\n' +
                `Ci sono ${repointedOffsets.size} offset salvati in memoria.\n\n` +
                'Se hai caricato una ROM DIVERSA, la memoria potrebbe\n' +
                'mostrare dati SBAGLIATI!\n\n' +
                'Opzioni:\n' +
                '‚Ä¢ OK = Usa memoria (ROM gi√† patchata)\n' +
                '‚Ä¢ ANNULLA = Reset memoria (ROM nuova)\n\n' +
                'Cosa vuoi fare?'
            );
            
            if (!useMemory) {
                repointedOffsets.clear();
                updateRepointMemoryUI();
                log('üóëÔ∏è Memoria resettata per nuova ROM', 'warning');
                toast('Memoria cancellata', 'success');
            } else {
                log(`üß† Uso memoria esistente: ${repointedOffsets.size} offset`, 'info');
            }
        }
        
        const mode = document.getElementById('extractMode').value;
        const englishOnly = document.getElementById('englishOnly').checked;
        const body = document.getElementById('resBody');
        body.innerHTML = "";
        scanResults = [];
        uniqueStrings.clear();
        
        const wrap = document.getElementById('scanProgress');
        const fill = document.getElementById('scanFill');
        const pct = document.getElementById('scanPct');
        const status = document.getElementById('scanStatus');
        wrap.classList.add('active');
        fill.style.width = '0%';
        
        log(`Scansione ${mode} avviata${englishOnly ? ' (SOLO inglese)' : ''}`, 'info');
        
        if (repointedOffsets.size > 0) {
            log(`üß† Memoria: ${repointedOffsets.size} offset repointed verranno skippati`, 'info');
        }

        const START = 0x200000, END = rom.length;
        let i = START, count = 0, rejected = 0, rejectedLang = 0;

        function update() {
            const p = Math.min(100, ((i - START) / (END - START)) * 100);
            fill.style.width = p.toFixed(1) + '%';
            pct.textContent = p.toFixed(0) + '%';
            status.textContent = `0x${i.toString(16).toUpperCase()} ‚Äî ${count} trovate${englishOnly ? ` | ${rejectedLang} non-inglese` : ''}`;
        }

        function doScan() {
            let limit = Math.min(i + 0x50000, END);
            for(; i < limit; i++) {
                if(rom[i] >= 0xBB && rom[i] <= 0xD4) {
                    const currentOffset = i;
                    let s = "", j = i;
                    while(j < rom.length && rom[j] !== 0xFF && s.length < 500) {
                        s += charMap[rom[j]] || '';
                        j++;
                    }
                    
                    // Skippa stringhe vuote o cancellate
                    if (!s || s.trim().length === 0) {
                        rejected++;
                        continue;
                    }
                    
                    // SKIPPA se offset √® stato repointed (memoria persistente)
                    if (repointedOffsets.has(currentOffset)) {
                        rejected++;
                        continue;
                    }

                    if(isValidText(s, mode) && !uniqueStrings.has(s)) {
                        // Filtro lingua se richiesto
                        if (englishOnly && !isEnglish(s)) {
                            rejectedLang++;
                            continue;
                        }
                        
                        uniqueStrings.add(s);
                        const off = "0x" + i.toString(16).toUpperCase();
                        const lang = isEnglish(s) ? 'üá¨üáß' : 'üáÆüáπ';
                        
                        // Salva SENZA tag nel risultato
                        scanResults.push({o: off, t: s, b: j - i, lang: lang});
                        
                        // Mostra CON tag nella tabella
                        if(count < 200) {
                            body.insertAdjacentHTML('beforeend', 
                                `<tr><td class="hex">${off}</td><td>${j-i}</td><td class="text-cell">${lang} ${s}</td></tr>`);
                        }
                        count++;
                        i = j;
                    } else rejected++;
                }
            }
            
            update();
            document.getElementById('stats').textContent = `‚úÖ ${count} | üö´ ${rejected}${englishOnly ? ` | üáÆüáπ ${rejectedLang}` : ''}`;
            
            if(i < END - 1) requestAnimationFrame(doScan);
            else {
                fill.style.width = '100%';
                pct.textContent = '100%';
                status.textContent = `‚úÖ ${count} stringhe${englishOnly ? ' inglesi' : ''} trovate`;
                log(`Completata: ${count} valide${englishOnly ? ` (${rejectedLang} non-inglesi escluse)` : ''}`, 'success');
                toast(`${count} stringhe trovate`, 'success');
                setTimeout(() => wrap.classList.remove('active'), 3000);
            }
        }
        doScan();
    }

    function exportTxt() {
        if(!scanResults.length) return toast('Niente da esportare', 'error');
        let out = "OFFSET | MAX_BYTE | TESTO\n";
        scanResults.forEach(r => {
            // NON includere tag lingua nel file - servono solo per visualizzazione
            out += `${r.o} | ${r.b} | ${r.t}\n`;
        });
        
        // UTF-8 BOM per compatibilit√†
        const BOM = '\uFEFF';
        const blob = new Blob([BOM + out], {type:'text/plain;charset=utf-8'});
        
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const mode = document.getElementById('extractMode').value;
        const englishOnly = document.getElementById('englishOnly').checked;
        a.download = `Trad_${mode}${englishOnly ? '_EN' : ''}_${Date.now()}.txt`;
        a.click();
        log('File esportato', 'success');
    }
    
    function downloadROM() {
        if (!rom) return toast('ROM non caricata!', 'error');
        
        const blob = new Blob([rom], {type: 'application/octet-stream'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `ROM_Patched_${Date.now()}.gba`;
        a.click();
        
        toast('ROM salvata!', 'success');
        log('‚úÖ ROM patchata scaricata', 'success');
    }
    
    async function fullReset() {
        const confirm = window.confirm(
            '‚ö†Ô∏è RESET COMPLETO\n\n' +
            'Questo canceller√†:\n' +
            '‚Ä¢ Memoria offset repointed\n' +
            '‚Ä¢ ROM in cache (IndexedDB)\n' +
            '‚Ä¢ File TXT salvati\n' +
            '‚Ä¢ Stato autosave\n\n' +
            'Usa quando carichi ROM diverse o hai problemi.\n\n' +
            'Procedere?'
        );
        
        if (!confirm) return;
        
        // Cancella memoria offset
        repointedOffsets.clear();
        updateRepointMemoryUI();
        
        // Cancella localStorage
        await clearState();
        
        // Reset variabili
        rom = null;
        scanResults = [];
        uniqueStrings.clear();
        romExpansions = 0;
        
        // Reset UI
        document.getElementById('romInfo').innerHTML = '‚è≥ Carica un file .gba';
        document.getElementById('downloadBtn').disabled = true;
        document.getElementById('resBody').innerHTML = '';
        document.getElementById('patchReport').innerHTML = '';
        document.getElementById('log').innerHTML = '';
        
        toast('‚úÖ Reset completo eseguito', 'success');
        log('üóëÔ∏è Reset completo: memoria, cache e stato cancellati', 'success');
        log('üí° Ora puoi caricare una nuova ROM senza interferenze', 'info');
    }


    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // RILEVAMENTO TABELLE CONTIGUE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function detectTables(lines) {
        // Crea array di entries con tutti i dati
        const entries = lines.map((l, idx) => {
            const parts = l.split('|');
            if (parts.length < 3) return null;
            const offset = parseInt(parts[0].trim(), 16);
            const maxByte = parseInt(parts[1].trim());
            let text = parts[2].trim();
            
            // Rimuovi tag lingua
            text = text.replace(/^\[üá¨üáß\]\s*/g, '').replace(/^\[üáÆüáπ\]\s*/g, '').replace(/^\[[^\]]+\]\s*/g, '');
            
            if (isNaN(offset) || isNaN(maxByte)) return null;
            return { offset, maxByte, text, lineIdx: idx };
        }).filter(e => e !== null);
        
        if (entries.length === 0) return [];
        
        // Ordina per offset
        entries.sort((a, b) => a.offset - b.offset);
        
        const tables = [];
        let currentTable = [entries[0]];
        
        for (let i = 1; i < entries.length; i++) {
            const prev = currentTable[currentTable.length - 1];
            const curr = entries[i];
            const distance = curr.offset - prev.offset;
            
            // Considera parte della stessa tabella se:
            // - Distanza < 100 byte
            // - maxByte simili (¬±5 byte)
            const maxByteClose = Math.abs(curr.maxByte - prev.maxByte) <= 5;
            
            if (distance > 0 && distance < 100 && maxByteClose) {
                currentTable.push(curr);
            } else {
                // Salva tabella se >= 5 stringhe
                if (currentTable.length >= 5) {
                    const avgDistance = (currentTable[currentTable.length - 1].offset - currentTable[0].offset) / (currentTable.length - 1);
                    tables.push({
                        start: currentTable[0].offset,
                        end: currentTable[currentTable.length - 1].offset,
                        count: currentTable.length,
                        entries: currentTable,
                        avgDistance: avgDistance,
                        maxByte: currentTable[0].maxByte
                    });
                }
                currentTable = [curr];
            }
        }
        
        // Ultima tabella
        if (currentTable.length >= 5) {
            const avgDistance = (currentTable[currentTable.length - 1].offset - currentTable[0].offset) / (currentTable.length - 1);
            tables.push({
                start: currentTable[0].offset,
                end: currentTable[currentTable.length - 1].offset,
                count: currentTable.length,
                entries: currentTable,
                avgDistance: avgDistance,
                maxByte: currentTable[0].maxByte
            });
        }
        
        return tables;
    }
    
    function findTableBasePointer(tableStart) {
        // METODO 1: Puntatore diretto
        const targetPtr = createPointer(tableStart);
        const found = [];
        
        // Cerca nelle prime 8MB (zona codice/dati)
        for (let i = 0; i < Math.min(rom.length, 0x800000); i++) {
            if (rom[i] === targetPtr[0] && 
                rom[i+1] === targetPtr[1] && 
                rom[i+2] === targetPtr[2] && 
                rom[i+3] === targetPtr[3]) {
                found.push({ offset: i, type: 'direct' });
            }
        }
        
        // METODO 2: Pattern ARM "ldr r0, =offset"
        // Pattern: LDR con literal pool
        const offsetBytes = [
            tableStart & 0xFF,
            (tableStart >> 8) & 0xFF,
            (tableStart >> 16) & 0xFF,
            (tableStart >> 24) & 0xFF
        ];
        
        for (let i = 0; i < Math.min(rom.length - 8, 0x800000); i++) {
            // Cerca LDR instruction (0x?? 0x?? 0x9F 0xE5 o 0x?? 0x?? 0x1F 0xE5)
            if ((rom[i+2] === 0x9F || rom[i+2] === 0x1F) && rom[i+3] === 0xE5) {
                // Calcola offset literal pool
                const pcOffset = (rom[i] & 0xFF) | ((rom[i+1] & 0x0F) << 8);
                const literalAddr = i + 8 + pcOffset;
                
                if (literalAddr < rom.length - 4) {
                    if (rom[literalAddr] === offsetBytes[0] &&
                        rom[literalAddr+1] === offsetBytes[1] &&
                        rom[literalAddr+2] === offsetBytes[2] &&
                        rom[literalAddr+3] === offsetBytes[3]) {
                        found.push({ offset: literalAddr, type: 'arm_ldr', instructionAddr: i });
                    }
                }
            }
        }
        
        // METODO 3: Cerca offset come valore immediato nel codice
        for (let i = 0; i < Math.min(rom.length - 4, 0x800000); i++) {
            if (rom[i] === offsetBytes[0] &&
                rom[i+1] === offsetBytes[1] &&
                rom[i+2] === offsetBytes[2] &&
                rom[i+3] === offsetBytes[3]) {
                // Verifica se √® in una zona di codice (allineato a 4)
                if (i % 4 === 0 && i >= 0x08000000 - 0x08000000 && i < 0x800000) {
                    found.push({ offset: i, type: 'immediate' });
                }
            }
        }
        
        return found;
    }
    
    function patchTableInBlock(table, stats) {
        log(`üì¶ TABELLA: ${table.count} stringhe @ 0x${table.start.toString(16).toUpperCase()}`, 'info');
        
        // Calcola spazio necessario con padding
        const maxLength = Math.max(...table.entries.map(e => textToBytes(e.text).length));
        const paddedLength = Math.ceil(maxLength / 16) * 16; // Allinea a 16 byte
        const totalSpace = paddedLength * table.count;
        
        log(`  üìè Spazio: ${totalSpace} byte (${paddedLength}b √ó ${table.count})`, 'info');
        
        // Trova spazio contiguo
        const newTableStart = findFreeSpace(totalSpace);
        log(`  üìç Nuovo offset: 0x${newTableStart.toString(16).toUpperCase()}`, 'info');
        
        // Scrivi tutte le stringhe con padding uniforme
        let currentOffset = newTableStart;
        for (const entry of table.entries) {
            const bytes = textToBytes(entry.text);
            rom.set(bytes, currentOffset);
            
            // Padding con 0xFF
            const padding = paddedLength - bytes.length;
            if (padding > 0) {
                rom.fill(0xFF, currentOffset + bytes.length, currentOffset + paddedLength);
            }
            
            // Traccia offset per memoria
            repointedOffsets.add(entry.offset);
            currentOffset += paddedLength;
        }
        
        // Cerca puntatori BASE
        const basePointers = findTableBasePointer(table.start);
        
        if (basePointers.length > 0) {
            log(`  üîç Trovati ${basePointers.length} puntatori BASE`, 'success');
            
            const newTablePtr = createPointer(newTableStart);
            for (const ptr of basePointers) {
                if (ptr.type === 'direct') {
                    rom.set(newTablePtr, ptr.offset);
                    log(`    ‚úÖ Diretto @ 0x${ptr.offset.toString(16).toUpperCase()}`, 'success');
                } else if (ptr.type === 'arm_ldr') {
                    // Aggiorna literal pool ARM
                    rom[ptr.offset] = newTableStart & 0xFF;
                    rom[ptr.offset+1] = (newTableStart >> 8) & 0xFF;
                    rom[ptr.offset+2] = (newTableStart >> 16) & 0xFF;
                    rom[ptr.offset+3] = (newTableStart >> 24) & 0xFF;
                    log(`    ‚úÖ ARM LDR @ 0x${ptr.instructionAddr.toString(16).toUpperCase()}`, 'success');
                } else if (ptr.type === 'immediate') {
                    rom.set(newTablePtr, ptr.offset);
                    log(`    ‚úÖ Immediato @ 0x${ptr.offset.toString(16).toUpperCase()}`, 'success');
                }
            }
            stats.tablesWithPointers = (stats.tablesWithPointers || 0) + 1;
        } else {
            log(`  ‚ö†Ô∏è NESSUN puntatore BASE trovato!`, 'warning');
            log(`  üí° Tabella potrebbe usare offset fissi - Potrebbero rimanere inglesi`, 'warning');
            stats.tablesWithoutPointers = (stats.tablesWithoutPointers || 0) + 1;
        }
        
        return table.count;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PATCH con AUTOSAVE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function textToBytes(text) {
        let bytes = [];
        for (let k = 0; k < text.length; k++) {
            if (text[k] === '\\' && text[k + 1]) {
                let code = text[k] + text[k + 1];
                if (invMap[code] !== undefined) { 
                    bytes.push(invMap[code]); 
                    k++; 
                    continue; 
                }
            }
            
            const char = text[k];
            if (invMap[char] !== undefined) {
                bytes.push(invMap[char]);
            } else {
                // Carattere non mappato - SKIPPA (emoji, simboli strani, ecc.)
                // NON scrivere 0x00 per caratteri sconosciuti
                continue;
            }
        }
        bytes.push(0xFF); // Terminatore
        return bytes;
    }

    function findFreeSpace(needed) {
        let count = 0;
        for (let i = rom.length - 1; i > 0x800000; i--) {
            if (rom[i] === 0xFF) count++;
            else count = 0;
            if (count >= needed + 10) return i + 5;
        }
        
        // ESPANSIONE AUTOMATICA - Se non c'√® spazio, allarga la ROM!
        const expandBy = Math.max(needed + 0x10000, 0x100000); // Aggiungi almeno 1MB
        const oldSize = rom.length;
        const newSize = oldSize + expandBy;
        
        romExpansions++; // Conta espansione
        log(`üìà Espansione ROM #${romExpansions}: ${(oldSize / 1024 / 1024).toFixed(1)}MB ‚Üí ${(newSize / 1024 / 1024).toFixed(1)}MB (+${(expandBy / 1024).toFixed(0)}KB)`, 'info');
        
        const newRom = new Uint8Array(newSize);
        newRom.set(rom); // Copia vecchia ROM
        newRom.fill(0xFF, oldSize); // Riempi nuovo spazio con 0xFF
        rom = newRom;
        
        // Ritorna offset nel nuovo spazio
        return oldSize + 5;
    }

    function createPointer(offset) {
        return new Uint8Array([offset & 0xFF, (offset >> 8) & 0xFF, (offset >> 16) & 0xFF, 0x08]);
    }

    function repointPointers(oldOff, newOff) {
        const oldPtr = createPointer(oldOff);
        const newPtr = createPointer(newOff);
        let found = 0;
        
        // Scansiona TUTTA la ROM (non solo da 0x0)
        // I puntatori possono essere ovunque, anche all'inizio
        for (let i = 0; i < rom.length - 4; i++) {
            if (rom[i] === oldPtr[0] && 
                rom[i+1] === oldPtr[1] && 
                rom[i+2] === oldPtr[2] && 
                rom[i+3] === oldPtr[3]) {
                rom.set(newPtr, i);
                found++;
            }
        }
        
        // Se non trovato nessun puntatore, prova pattern alternativi
        if (found === 0) {
            // Cerca offset senza byte 0x08 (alcuni giochi usano offset diretti)
            const offset3Bytes = new Uint8Array([oldOff & 0xFF, (oldOff >> 8) & 0xFF, (oldOff >> 16) & 0xFF]);
            for (let i = 0; i < rom.length - 3; i++) {
                if (rom[i] === offset3Bytes[0] && 
                    rom[i+1] === offset3Bytes[1] && 
                    rom[i+2] === offset3Bytes[2]) {
                    // Verifica che non sia un falso positivo
                    if (i < 4 || rom[i-1] !== 0x08) { // Non √® gi√† un puntatore completo
                        const new3Bytes = new Uint8Array([newOff & 0xFF, (newOff >> 8) & 0xFF, (newOff >> 16) & 0xFF]);
                        rom.set(new3Bytes, i);
                        found++;
                    }
                }
            }
        }
        
        return found;
    }

    async function patch() {
        const file = document.getElementById('txtFile').files[0];
        if (!file || !rom) return toast('ROM o TXT mancante', 'error');

        const txtContent = await file.text();
        
        // RILEVA SE √à UN FILE SHORT (mosse/oggetti/abilit√†)
        const lines = txtContent.split('\n').slice(1, 20); // Prendi prime 20 righe
        let shortCount = 0;
        for (let line of lines) {
            const parts = line.split('|');
            if (parts.length >= 3) {
                const text = parts[2].trim().replace(/^\[[üá¨üáßüáÆüáπ]+\]\s*/, '');
                // Se il testo √® tutto maiuscolo e corto, √® probabilmente SHORT
                if (text === text.toUpperCase() && text.length < 25 && !text.includes('\\n')) {
                    shortCount++;
                }
            }
        }
        
        const isShortFile = shortCount > 10; // Se pi√π di 10 su 20 sono SHORT
        
        if (isShortFile) {
            const intelligentEnabled = document.getElementById('intelligentTables').checked;
            const strategyText = intelligentEnabled ? 
                'üß† Sistema Intelligente Tabelle:\n' +
                '‚Ä¢ Auto-rileva tabelle contigue\n' +
                '‚Ä¢ Sposta tabelle in blocco\n' +
                '‚Ä¢ Cerca puntatori BASE (3 metodi)\n' +
                '‚Ä¢ Cerca pattern ARM nel codice\n' +
                '‚Ä¢ Fallback automatico\n\n' :
                'Strategia Standard:\n' +
                '‚Ä¢ Sposta stringhe una per una\n\n';
            
            const confirm = window.confirm(
                '‚ö†Ô∏è FILE SHORT RILEVATO\n\n' +
                strategyText +
                'Caratteristiche:\n' +
                '‚Ä¢ Italiano ‚Üí spazio libero üîÄ\n' +
                '‚Ä¢ Inglese ‚Üí lasciato intatto (no crash) ‚úÖ\n' +
                '‚Ä¢ Memoria ‚Üí skippa inglese in scansione üß†\n' +
                '‚Ä¢ ROM ‚Üí espansa se serve üìà\n\n' +
                'ROM funziona, scansione pulita!\n\n' +
                'Vuoi procedere?'
            );
            
            if (!confirm) {
                toast('Patch annullata', 'warning');
                return;
            }
            
            log('üîÄ Strategia SPOSTA+MEMORIA attivata - Inglese lasciato intatto', 'info');
        }
        
        // Salva file TXT in IndexedDB per resume
        try {
            await saveTxtContent(txtContent);
            log('‚úÖ File TXT salvato per resume automatico', 'success');
            toast('üíæ ROM e TXT salvati - patch protetta', 'success');
        } catch(err) {
            log('Avviso: TXT non salvato', 'warning');
        }

        await doPatch(txtContent, 0);
    }

    async function resumePatch() {
        document.getElementById('resumeModal').classList.remove('active');
        
        log('‚è≥ Ripristino dati salvati...', 'info');
        toast('üîÑ Caricamento dati...', 'info');
        
        // Carica ROM da IndexedDB
        const savedROM = await loadROM();
        if (!savedROM) {
            toast('‚ùå ROM non trovata! Ricaricala manualmente', 'error');
            log('ROM non trovata in memoria', 'error');
            return;
        }
        rom = savedROM;
        const mb = (rom.length / 1024 / 1024).toFixed(1);
        const info = document.getElementById('romInfo');
        info.innerHTML = `‚úÖ ROM ripristinata (${mb} MB) üíæ <span style="color:var(--success)">Da memoria</span>`;
        info.classList.add('saved');
        log('‚úÖ ROM caricata automaticamente', 'success');
        
        // Carica file TXT da IndexedDB
        const txtContent = await loadTxtContent();
        if (!txtContent) {
            toast('‚ùå File TXT non trovato! Ricaricalo manualmente', 'error');
            log('File TXT non trovato in memoria', 'error');
            return;
        }
        log('‚úÖ File TXT caricato automaticamente', 'success');
        
        // Carica stato
        const state = loadState();
        if (!state) {
            toast('Stato non trovato', 'error');
            return;
        }
        
        log(`üîÑ Ripresa da riga ${state.lastIndex}/${state.totalLines}`, 'success');
        toast('üöÄ Patch ripresa automaticamente!', 'success');
        
        // Riprendi patch da dove si era fermata
        await doPatch(txtContent, state.lastIndex, state.stats);
    }

    async function doPatch(txtContent, startIdx = 0, savedStats = null) {
        const btn = document.getElementById('patchBtn');
        btn.disabled = true;
        
        romExpansions = 0; // Reset contatore espansioni

        const wrap = document.getElementById('patchProgress');
        const fill = document.getElementById('patchFill');
        const pct = document.getElementById('patchPct');
        const status = document.getElementById('patchStatus');
        wrap.classList.add('active');
        fill.style.width = '0%';

        const lines = txtContent.split('\n').filter(l => l.includes('|') && !l.startsWith('OFFSET'));
        const total = lines.length;
        
        let idx = startIdx;
        let stats = savedStats || { total: 0, repointed: 0, failed: 0, protected: 0, noPointers: 0, truncated: 0, expanded: 0 };

        log(`Patch ${startIdx > 0 ? 'ripresa' : 'avviata'} da riga ${idx}/${total}`);
        document.getElementById('patchReport').innerHTML = '';
        
        // ============================================================
        // SISTEMA INTELLIGENTE TABELLE
        // ============================================================
        const intelligentTables = document.getElementById('intelligentTables').checked;
        const processedOffsets = new Set(); // Traccia offset gi√† processati dalle tabelle
        
        if (intelligentTables && startIdx === 0) {
            log('üß† Sistema Intelligente Tabelle attivato', 'info');
            
            const tables = detectTables(lines);
            
            if (tables.length > 0) {
                log(`üìä Rilevate ${tables.length} tabelle contigue`, 'success');
                stats.tablesDetected = tables.length;
                stats.tablesWithPointers = 0;
                stats.tablesWithoutPointers = 0;
                
                // Processa ogni tabella
                for (let i = 0; i < tables.length; i++) {
                    const table = tables[i];
                    try {
                        const count = patchTableInBlock(table, stats);
                        stats.repointed += count;
                        
                        // Segna offset come processati
                        for (const entry of table.entries) {
                            processedOffsets.add(entry.offset);
                        }
                        
                        fill.style.width = `${((i + 1) / tables.length) * 50}%`; // 50% per tabelle
                        await new Promise(r => setTimeout(r, 10));
                    } catch(e) {
                        log(`‚ùå Errore tabella ${i+1}: ${e.message}`, 'error');
                        stats.failed += table.count;
                    }
                }
                
                log(`‚úÖ Tabelle processate: ${tables.length}`, 'success');
                log(`  ‚Ä¢ Con puntatori: ${stats.tablesWithPointers}`, 'success');
                log(`  ‚Ä¢ Senza puntatori: ${stats.tablesWithoutPointers}`, 'warning');
            } else {
                log('‚ö†Ô∏è Nessuna tabella rilevata - Uso metodo standard', 'warning');
            }
        }

        function processChunk() {
            const chunkEnd = Math.min(idx + 20, total);

            for (; idx < chunkEnd; idx++) {
                const parts = lines[idx].split('|').map(s => s.trim());
                if (parts.length < 3) continue;

                const [offStr, maxBStr, textRaw] = parts;
                
                // Rimuovi tag lingua in modo pi√π robusto
                let text = textRaw
                    .replace(/^\[üá¨üáß\]\s*/g, '')
                    .replace(/^\[üáÆüáπ\]\s*/g, '')
                    .replace(/^\[[^\]]+\]\s*/g, ''); // Fallback per altri tag
                
                const oldOff = parseInt(offStr, 16);
                const maxB = parseInt(maxBStr);

                if (isNaN(oldOff) || oldOff < 0x200000) {
                    stats.protected++;
                    continue;
                }
                
                // Skippa se gi√† processato dalle tabelle
                if (processedOffsets.has(oldOff)) {
                    continue;
                }

                stats.total++;
                const newBytes = textToBytes(text);
                const forceOverwrite = document.getElementById('forceOverwrite').checked;

                try {
                    // STRATEGIA: Sposta TUTTO nello spazio libero ma LASCIA inglese originale
                    // (cancellarlo causa crash ROM!)
                    
                    if (forceOverwrite && newBytes.length > maxB + 1) {
                        // CASO 1: Force overwrite attivo + stringa troppo lunga = TRONCA
                        const truncated = newBytes.slice(0, maxB);
                        truncated.push(0xFF);
                        rom.set(truncated, oldOff);
                        stats.truncated++;
                        repointedOffsets.add(oldOff); // Skippa in scansioni future
                    } else {
                        // CASO 2: Sposta SEMPRE nello spazio libero
                        const newOff = findFreeSpace(newBytes.length);
                        // findFreeSpace NON pu√≤ pi√π fallire (espande automaticamente)
                        
                        // Scrivi nuova stringa nello spazio libero
                        rom.set(newBytes, newOff);
                        
                        // NON cancellare l'inglese originale! (causa crash)
                        // Lascialo com'√®, ma salvalo in memoria per skipparla in scansione
                        repointedOffsets.add(oldOff);
                        stats.repointed++;
                        
                        // PROVA a trovare e aggiornare puntatori
                        const ptrCount = repointPointers(oldOff, newOff);
                        
                        if (ptrCount === 0) {
                            stats.noPointers++;
                        }
                    }
                } catch(e) {
                    stats.failed++;
                    log(`‚ùå ${offStr}: ${e.message}`, 'error');
                }

                // AUTOSAVE ogni 10 stringhe
                if ((idx + 1) % AUTOSAVE_INTERVAL === 0) {
                    saveState(idx + 1, stats, lines);
                }
            }

            const p = total > 0 ? Math.min(100, (idx / total) * 100) : 100;
            fill.style.width = p.toFixed(1) + '%';
            pct.textContent = p.toFixed(0) + '%';
            status.textContent = `${idx}/${total} ‚Äî ‚úÖ${stats.overwritten} üîÄ${stats.repointed} ‚ùå${stats.failed}`;

            if (idx < total) {
                requestAnimationFrame(processChunk);
            } else {
                // FINE
                clearState();
                fill.style.width = '100%';
                pct.textContent = '100%';
                status.textContent = '‚úÖ Completata!';
                
                stats.expanded = romExpansions; // Salva contatore espansioni

                const truncPercent = stats.truncated > 0 ? Math.round((stats.truncated / stats.total) * 100) : 0;
                
                document.getElementById('patchReport').innerHTML = `
                    <div class="report">
                        <div class="report-item"><span>Processate</span><strong>${stats.total}</strong></div>
                        ${stats.tablesDetected > 0 ? `<div class="report-item"><span>üì¶ Tabelle</span><strong style="color:var(--accent)">${stats.tablesDetected} (‚úÖ${stats.tablesWithPointers} ‚ö†Ô∏è${stats.tablesWithoutPointers})</strong></div>` : ''}
                        <div class="report-item"><span>üîÄ Spostate</span><strong style="color:var(--accent)">${stats.repointed}</strong></div>
                        ${stats.noPointers > 0 ? `<div class="report-item"><span>‚ö†Ô∏è Senza ptr</span><strong style="color:var(--warning)">${stats.noPointers}</strong></div>` : ''}
                        ${stats.truncated > 0 ? `<div class="report-item"><span>‚úÇÔ∏è Troncate</span><strong style="color:var(--warning)">${stats.truncated} (${truncPercent}%)</strong></div>` : ''}
                        ${stats.expanded > 0 ? `<div class="report-item"><span>üìà Espansioni ROM</span><strong style="color:var(--accent)">${stats.expanded}</strong></div>` : ''}
                        <div class="report-item"><span>üõ°Ô∏è Protette</span><strong style="color:var(--text-dim)">${stats.protected}</strong></div>
                        ${stats.failed > 0 ? `<div class="report-item"><span>‚ùå Fallite</span><strong style="color:var(--danger)">${stats.failed}</strong></div>` : ''}
                    </div>`;

                log(`‚úÖ Patch completata: ${stats.repointed}/${stats.total}`, 'success');
                log(`üß† ${repointedOffsets.size} offset salvati in memoria - non verranno mostrati in scansioni future`, 'info');
                
                if (stats.expanded > 0) {
                    const finalSize = (rom.length / 1024 / 1024).toFixed(1);
                    log(`üìà ROM espansa ${stats.expanded} volte - Dimensione finale: ${finalSize}MB`, 'info');
                }
                
                if (stats.noPointers > 0) {
                    log(`‚ö†Ô∏è ${stats.noPointers} stringhe senza puntatori trovati`, 'warning');
                    log(`üí° Se gioco usa offset fissi, potrebbero rimanere inglesi`, 'warning');
                }
                
                updateRepointMemoryUI(); // Aggiorna UI memoria
                
                if (stats.truncated > 0) {
                    const truncPercent = Math.round((stats.truncated / stats.total) * 100);
                    log(`‚úÇÔ∏è ${stats.truncated} stringhe troncate manualmente (${truncPercent}%)`, 'warning');
                }

                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([rom], {type:'application/octet-stream'}));
                a.download = 'Pokemon_ITA.gba';
                a.click();

                toast('ROM patchata scaricata', 'success');
                btn.disabled = false;
            }
        }

        processChunk();
    }
</script>
</body>
</html>

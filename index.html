<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GBA Translator Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg: #0a0e1a;
            --card: #12182a;
            --accent: #6366f1;
            --text: #e2e8f0;
            --text-dim: #94a3b8;
            --border: #1f2937;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0.75rem;
        }

        /* Header minimalista */
        .header {
            text-align: center;
            padding: 1.5rem 0.75rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--accent);
        }

        .header h1 {
            font-size: clamp(1.25rem, 5vw, 1.75rem);
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }

        .header p {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        /* Sezioni compatte */
        .section {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.875rem;
            margin-bottom: 0.75rem;
        }

        .section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.625rem;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        /* Input minimalisti */
        input[type="file"], select, button {
            width: 100%;
            padding: 0.625rem 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-size: 0.875rem;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: auto;
            cursor: pointer;
            accent-color: var(--accent);
        }

        label {
            user-select: none;
        }

        button {
            font-weight: 600;
            background: var(--accent);
            border: none;
            margin-top: 0.5rem;
            transition: opacity 0.2s;
        }

        button:hover:not(:disabled) { opacity: 0.85; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .btn-success { background: var(--success); }

        /* Info compatta */
        .info {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg);
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .info.saved {
            border-left: 3px solid var(--success);
            color: var(--success);
        }

        /* Preview box minimalista */
        .preview {
            margin-top: 0.625rem;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            overflow: hidden;
            background: var(--bg);
        }

        .preview-header {
            background: var(--card);
            padding: 0.5rem 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
        }

        .preview-box {
            height: clamp(250px, 35vh, 400px);
            overflow: auto;
        }

        .preview-box::-webkit-scrollbar { width: 6px; height: 6px; }
        .preview-box::-webkit-scrollbar-track { background: var(--bg); }
        .preview-box::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }

        /* Tabella compatta */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }

        th {
            position: sticky;
            top: 0;
            background: var(--card);
            padding: 0.5rem;
            text-align: left;
            font-weight: 600;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
        }

        td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        tr:hover { background: var(--card); }

        .hex { color: #a78bfa; font-weight: 600; }
        .text-cell { word-break: break-word; }

        /* Progress bar minimalista */
        .progress {
            margin-top: 0.5rem;
            display: none;
        }
        .progress.active { display: block; }

        .progress-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }

        .progress-bar {
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            transition: width 0.2s;
        }

        .progress-status {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 0.25rem;
            font-style: italic;
        }

        /* Log minimalista */
        .log {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.5rem;
            height: 80px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            color: var(--text-dim);
            line-height: 1.4;
        }

        .log::-webkit-scrollbar { width: 4px; }
        .log::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 2px; }

        .log-success { color: var(--success); }
        .log-error { color: var(--danger); }
        .log-warning { color: var(--warning); }

        /* Report compatto */
        .report {
            margin-top: 0.625rem;
            padding: 0.75rem;
            background: var(--bg);
            border-radius: 0.375rem;
            border-left: 3px solid var(--success);
            font-size: 0.75rem;
        }

        .report-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        /* Toast minimalista */
        .toast {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.75rem 1rem;
            font-size: 0.8rem;
            max-width: 90vw;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 1000;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.success { border-left: 3px solid var(--success); }
        .toast.error { border-left: 3px solid var(--danger); }
        .toast.warning { border-left: 3px solid var(--warning); }

        /* Dialog Resume */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .modal.active { display: flex; }

        .modal-content {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1.25rem;
            max-width: 400px;
            margin: 1rem;
        }

        .modal-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.75rem;
        }

        .modal-text {
            font-size: 0.875rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.5rem;
        }

        .modal-actions button {
            margin: 0;
            flex: 1;
        }

        /* Mobile ottimizzato */
        @media (max-width: 640px) {
            .container { padding: 0.5rem; }
            .section { padding: 0.625rem; }
            th, td { padding: 0.375rem; font-size: 0.7rem; }
            .text-cell { max-width: 150px; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>ğŸ® GBA Translator Pro</h1>
        <p>Filtri ultra + Autosave intelligente</p>
    </div>

    <!-- ROM -->
    <div class="section">
        <div class="section-title">ğŸ“ ROM</div>
        <input type="file" id="romFile" accept=".gba">
        <div class="info" id="romInfo">â³ Carica un file .gba</div>
    </div>

    <!-- Scansione -->
    <div class="section">
        <div class="section-title">ğŸ” Estrazione</div>
        <select id="extractMode">
            <option value="short">âš”ï¸ Mosse/Oggetti (parole singole)</option>
            <option value="dialogs">ğŸ’¬ Dialoghi (filtro medio)</option>
            <option value="all">ğŸŒ TUTTO il testo (nessun filtro)</option>
        </select>
        <label style="display:flex;align-items:center;gap:0.5rem;margin-top:0.5rem;font-size:0.8rem;cursor:pointer">
            <input type="checkbox" id="englishOnly" style="width:auto">
            <span>Estrai solo testo inglese (ğŸ‡¬ğŸ‡§ rilevamento automatico)</span>
        </label>
        <div id="repointMemory" style="display:none;font-size:0.7rem;color:var(--accent);margin-top:0.5rem;padding:0.5rem;background:var(--bg);border-radius:0.25rem;border-left:2px solid var(--accent)">
            ğŸ§  Memoria: <strong id="repointCount">0</strong> offset repointed salvati
            <button onclick="clearRepointMemory()" style="margin-left:0.5rem;padding:0.25rem 0.5rem;font-size:0.65rem;width:auto;background:var(--danger)">
                ğŸ—‘ï¸ Cancella memoria
            </button>
        </div>
        <button onclick="scan()">Scansiona ROM</button>
        
        <div class="progress" id="scanProgress">
            <div class="progress-info">
                <span>Scansione...</span>
                <span id="scanPct">0%</span>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="scanFill"></div></div>
            <div class="progress-status" id="scanStatus"></div>
        </div>
        
        <div class="preview">
            <div class="preview-header">
                <span id="stats">Nessun dato</span>
                <button class="btn-outline" onclick="exportTxt()" style="width:auto;padding:0.375rem 0.75rem;margin:0;font-size:0.7rem">ğŸ’¾ TXT</button>
            </div>
            <div class="preview-box">
                <table>
                    <thead><tr><th>Offset</th><th>Byte</th><th>Testo</th></tr></thead>
                    <tbody id="resBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Patch -->
    <div class="section">
        <div class="section-title">âš¡ Traduzione</div>
        <input type="file" id="txtFile" accept=".txt">
        <label style="display:flex;align-items:center;gap:0.5rem;margin-top:0.5rem;font-size:0.75rem;cursor:pointer">
            <input type="checkbox" id="forceOverwrite" style="width:auto">
            <span style="color:var(--warning)">âš ï¸ Forza sovrascrivi (tronca se troppo lungo)</span>
        </label>
        <button class="btn-success" onclick="patch()" id="patchBtn">Applica Patch</button>
        
        <div class="progress" id="patchProgress">
            <div class="progress-info">
                <span>Patching...</span>
                <span id="patchPct">0%</span>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="patchFill"></div></div>
            <div class="progress-status" id="patchStatus"></div>
        </div>
        
        <div id="patchReport"></div>
    </div>

    <!-- Log -->
    <div class="log" id="log">âœ… Sistema pronto</div>
</div>

<!-- Modal Resume -->
<div class="modal" id="resumeModal">
    <div class="modal-content">
        <div class="modal-title">ğŸ”„ Riprendere patch automaticamente?</div>
        <div class="modal-text" id="resumeText"></div>
        <div style="font-size:0.75rem;color:var(--text-dim);margin-bottom:1rem;padding:0.5rem;background:var(--bg);border-radius:0.25rem;border-left:2px solid var(--accent)">
            âœ… ROM e file TXT giÃ  salvati in memoria<br>
            âœ… Stato patch preservato<br>
            âœ… Click "Riprendi" per continuare automaticamente
        </div>
        <div class="modal-actions">
            <button class="btn-outline" onclick="clearResume()">Ricomincia da zero</button>
            <button onclick="resumePatch()">â–¶ï¸ Riprendi patch</button>
        </div>
    </div>
</div>

<script>
    const charMap = { 0x00: ' ', 0x01: 'Ã€', 0x02: 'Ã', 0x03: 'Ã‚', 0x04: 'Ã‡', 0x05: 'Ãˆ', 0x06: 'Ã‰', 0x07: 'ÃŠ', 0x08: 'Ã‹', 0x09: 'ÃŒ', 0x0B: 'Ã', 0x0C: 'Ã', 0x0D: 'Ã’', 0x0E: 'Ã“', 0x0F: 'Ã”', 0x10: 'Å’', 0x11: 'Ã™', 0x12: 'Ãš', 0x13: 'Ã›', 0x14: 'Å¸', 0x15: 'ÃŸ', 0x16: 'Ã ', 0x17: 'Ã¡', 0x19: 'Ã§', 0x1A: 'Ã¨', 0x1B: 'Ã©', 0x1C: 'Ãª', 0x1D: 'Ã«', 0x1E: 'Ã¬', 0x20: 'Ã®', 0x21: 'Ã¯', 0x22: 'Ã²', 0x23: 'Ã³', 0x24: 'Ã´', 0x25: 'Å“', 0x26: 'Ã¹', 0x27: 'Ãº', 0x28: 'Ã»', 0x29: 'Ã¿', 0x2D: '&', 0x2E: '+', 0xAB: '!', 0xAC: '?', 0xAD: '.', 0xAE: '-', 0xB0: '...', 0xB8: ',', 0xBB: 'A', 0xBC: 'B', 0xBD: 'C', 0xBE: 'D', 0xBF: 'E', 0xC0: 'F', 0xC1: 'G', 0xC2: 'H', 0xC3: 'I', 0xC4: 'J', 0xC5: 'K', 0xC6: 'L', 0xC7: 'M', 0xC8: 'N', 0xC9: 'O', 0xCA: 'P', 0xCB: 'Q', 0xCC: 'R', 0xCD: 'S', 0xCE: 'T', 0xCF: 'U', 0xD0: 'V', 0xD1: 'W', 0xD2: 'X', 0xD3: 'Y', 0xD4: 'Z', 0xD5: 'a', 0xD6: 'b', 0xD7: 'c', 0xD8: 'd', 0xD9: 'e', 0xDA: 'f', 0xDB: 'g', 0xDC: 'h', 0xDD: 'i', 0xDE: 'j', 0xDF: 'k', 0xE0: 'l', 0xE1: 'm', 0xE2: 'n', 0xE3: 'o', 0xE4: 'p', 0xE5: 'q', 0xE6: 'r', 0xE7: 's', 0xE8: 't', 0xE9: 'u', 0xEA: 'v', 0xEB: 'w', 0xEC: 'x', 0xED: 'y', 0xEE: 'z', 0xFA: '\\l', 0xFB: '\\p', 0xFD: '\\v', 0xFE: '\\n' };
    const invMap = Object.fromEntries(Object.entries(charMap).map(([k,v]) => [v, parseInt(k)]));
    
    const validSyllables = ['TI','TA','TO','TE','TU','CA','CO','CHE','CHI','SA','SO','SE','SI','SU','LA','LE','LI','LO','LU','MA','ME','MI','MO','MU','NA','NE','NI','NO','RA','RE','RI','RO','RU','PA','PE','PI','PO','PU','BA','BE','BI','BO','DA','DE','DI','DO','DU','GI','GA','GO','GU','GE','FA','FI','FO','FE','VA','VE','VI','VO','VU','ZA','ZE','ZI','ZO','ZU','ZZA','ZZO','ZZI','TRA','TRE','TRI','TRO','PRE','PRA','PRO','STA','STO','STI','STE','THE','ING','ION','TER','EST','FOR','TIO','ATI','ATE','ICA','ICO','URA','URE','ORA','ORE','ORI','ERA','ERE','ERI','ARO','ARE','ARI','CHA','CHO','CHU','GHA','GHE','GHI','GHO','GLI','GNA','GNE','GNI','GNO','SCA','SCE','SCI','SCO','SCU','SHA','SHE','SHI','SHO','SPE','SPI','SPO','QUA','QUE','QUI','QUO'];
    
    const blockedSounds = ['HA','HE','HI','HO','HU','BA','BE','BI','BO','BU','RA','RE','RI','RO','RU','FO','FA','FU','FE','FI','LA','LE','LI','LO','LU','WA','WE','WI','WO','WU','YA','YE','YI','YO','YU','ZA','ZE','ZI','ZO','ZU','HAHA','HOHO','HEHE','HIHI','BABA','BOBO','RARA','RORO','WAWA','WOWO','YAYA','YOYO','GAGA','GOGO','CATT','MEO','DU','TU','GU','NU','MU','SU','CU','PU'];
    
    const knownWords = ['ITEM','BALL','MEGA','MOVE','HOLD','BACK','EXIT','SURF','FIRE','AQUA','ROCK','LEAF','VOLT','BOLT','STAR','MOON','STONE','WATER','GRASS','TOXIC','STEEL','BURN','FREEZE','SLEEP','DRAGON','GHOST','FAIRY','FIGHT','GROUND','FLYING','POISON','NORMAL','PSYCHIC','SUPER','HYPER','MAX','FULL','HEAL','CURE','FRESH','GUARD','POTION','ELIXIR','ETHER','REVIVE','ESCAPE','ROPE','REPEL','BADGE','CASE','BIKE','COIN','GOOD','GREAT','ULTRA','MASTER','SAFARI','LEVEL','LUXURY','NEST','NET','DIVE','TIMER','REPEAT','PREMIER','DUSK','QUICK','ATTACK','DEFENSE','SPECIAL','SPEED','ACCURACY','EVASION','CRITICAL'];
    
    // Parole comuni inglesi per rilevamento lingua
    const englishWords = ['THE','AND','YOU','THAT','WAS','FOR','ARE','WITH','HIS','THEY','THIS','HAVE','FROM','ONE','HAD','BUT','WHAT','ALL','WERE','WHEN','YOUR','CAN','SAID','THERE','USE','EACH','WHICH','SHE','HOW','THEIR','WILL','OTHER','ABOUT','OUT','MANY','THEN','THEM','THESE','SOME','HER','WOULD','MAKE','LIKE','HIM','INTO','TIME','HAS','LOOK','TWO','MORE','WRITE','SEE','NUMBER','WAY','COULD','PEOPLE','THAN','FIRST','BEEN','CALL','WHO','OIL','NOW','FIND','LONG','DOWN','DAY','DID','GET','COME','MADE','MAY','PART','OVER','NEW','SOUND','TAKE','ONLY','LITTLE','WORK','KNOW','PLACE','YEAR','LIVE','BACK','GIVE','MOST','VERY','AFTER','THING','OUR','JUST','NAME','GOOD','SENTENCE','MAN','THINK','SAY','GREAT','WHERE','HELP','THROUGH','MUCH','BEFORE','LINE','RIGHT','TOO','MEAN','OLD','ANY','SAME','TELL','FOLLOW','CAME','WANT','SHOW','ALSO','AROUND','FORM','THREE','SMALL','SET','PUT','END','WHY','ASKED','WENT','MEN','READ','NEED','LAND','DIFFERENT','HOME','MOVE','TRY','KIND','HAND','PICTURE','AGAIN','CHANGE','OFF','PLAY','SPELL','AIR','AWAY','ANIMAL','HOUSE','POINT','PAGE','LETTER','MOTHER','ANSWER','FOUND','STUDY','STILL','LEARN','SHOULD','WORLD','HIGH','EVERY','NEAR','ADD','FOOD','BETWEEN','OWN','BELOW','COUNTRY','PLANT','LAST','SCHOOL','FATHER','KEEP','TREE','NEVER','START','CITY','EARTH','EYE','LIGHT','THOUGHT','HEAD','UNDER','STORY','SAW','LEFT','FEW','WHILE','ALONG','MIGHT','CLOSE','SOMETHING','SEEM','NEXT','HARD','OPEN','EXAMPLE','BEGIN','LIFE','ALWAYS','THOSE','BOTH','PAPER','TOGETHER','GOT','GROUP','OFTEN','RUN','IMPORTANT','UNTIL','CHILDREN','SIDE','FEET','CAR','MILE','NIGHT','WALK','WHITE','SEA','BEGAN','GROW','TOOK','RIVER','FOUR','CARRY','STATE','ONCE','BOOK','HEAR','STOP','WITHOUT','SECOND','LATER','MISS','IDEA','ENOUGH','EAT','FACE','WATCH','FAR','INDIAN','REAL','ALMOST','LET','ABOVE','GIRL','SOMETIMES','MOUNTAIN','CUT','YOUNG','TALK','SOON','LIST','SONG','LEAVE','FAMILY','BODY','MUSIC','COLOR','STAND','SUN','QUESTIONS','FISH','AREA','MARK','DOG','HORSE','BIRD','PROBLEM','COMPLETE','ROOM','KNEW','SINCE','EVER','PIECE','TOLD','USUALLY','DIDN','FRIENDS','EASY','HEARD','ORDER','RED','DOOR','SURE','BECOME','TOP','SHIP','ACROSS','TODAY','DURING','SHORT','BETTER','BEST','HOWEVER','LOW','HOURS','BLACK','PRODUCTS','HAPPENED','WHOLE','MEASURE','REMEMBER','EARLY','WAVES','REACHED','LISTEN','WIND','ROCK','SPACE','COVERED','FAST','SEVERAL','HOLD','HIMSELF','TOWARD','FIVE','STEP','MORNING','PASSED','VOWEL','TRUE','HUNDRED','AGAINST','PATTERN','NUMERAL','TABLE','NORTH','SLOWLY','MONEY','MAP','FARM','PULLED','DRAW','VOICE','SEEN','COLD','CRIED','PLAN','NOTICE','SOUTH','SING','WAR','GROUND','FALL','KING','TOWN','UNIT','FIGURE','CERTAIN','FIELD','TRAVEL','WOOD','FIRE','UPON','DONE','ENGLISH','ROAD','HALF','TEN','FLY','GAVE','BOX','FINALLY','WAIT','CORRECT','GAME','SPECIAL','HEAVY','FINE','PAIR','CIRCLE','INCLUDE','BUILT','CANT','MATTER','SQUARE','SYLLABLES','PERHAPS','BILL','FELT','SUDDENLY','TEST','DIRECTION','CENTER','FARMERS','READY','ANYTHING','DIVIDED','GENERAL','ENERGY','SUBJECT','EUROPE','MOON','REGION','RETURN','BELIEVE','DANCE','MEMBERS','PICKED','SIMPLE','CELLS','PAINT','MIND','LOVE','CAUSE','RAIN','EXERCISE','EGGS','TRAIN','BLUE','WISH','DROP','DEVELOPED','WINDOW','DIFFERENCE','DISTANCE','HEART','SITE','SUM','SUMMER','WALL','FOREST','PROBABLY','LEGS','SAT','MAIN','WINTER','WIDE','WRITTEN','LENGTH','REASON','KEPT','INTEREST','ARMS','BROTHER','RACE','PRESENT','BEAUTIFUL','STORE','JOB','EDGE','PAST','SIGN','RECORD','FINISHED','DISCOVERED','WILD','HAPPY','BESIDE','GONE','PLANE','INSTEAD','THOUGH','YELLOW','HUGE','STREAM','BORN','LABOR','SHOES','LOUD','RIDING','ALREADY','STRANGE','CAUGHT','FELL','TEAM','GOD','CAPTAIN','DIRECT','RING','SERVE','CHILD','DESERT','INCREASE','HISTORY','COST','MAYBE','BUSINESS','SEPARATE','BREAK','UNCLE','HUNTING','FLOW','LADY','STUDENTS','HUMAN','ART','FEELING','SUPPLY','CORNER','ELECTRIC','INSECTS','CROPS','TONE','HIT','SAND','DOCTOR','PROVIDE','THUS','WONT','COOK','BONES','TAIL','BOARD','MODERN','COMPOUND','MINE','WASNT','FIT','ADDITION','BELONG','SAFE','SOLDIERS','GUESS','CHOSEN','FEAR','WORKERS','WASHINGTON','GREEK','WOMEN','BOUGHT','LED','MARCH','NORTHERN','CREATE','BRITISH','DIFFICULT','MATCH','WIN','DOESNT','STEEL','TOTAL','DEAL','DETERMINE','EVENING','NOR','ROPE','COTTON','APPLE','DETAILS','ENTIRE','CORN','SUBSTANCES','SMELL','TOOLS','CONDITIONS','COWS','TRACK','ARRIVED','LOCATED','SIR','SEAT','DIVISION','EFFECT','UNDERLINE','FIRE','TROUBLE','PARTY','BUILD','EXPECT','STAY','GREEN','KNOWN','ISLAND','WEEK','LESS','MACHINE','BASE','AGO','STOOD','PLANE','SYSTEM','BEHIND','RAN','ROUND','BOAT','GAME','FORCE','BROUGHT','UNDERSTAND','WARM','COMMON','BRING','EXPLAIN','DRY','THOUGH','LANGUAGE','SHAPE','DEEP','THOUSANDS','YES','CLEAR','EQUATION','YET','GOVERNMENT','FILLED','HEAT','FULL','HOT','CHECK','OBJECT','AM','RULE','AMONG','NOUN','POWER','CANNOT','ABLE','SIX','SIZE','DARK','BALL','MATERIAL','SPECIAL','HEAVY','FINE','PAIR','CIRCLE','INCLUDE','BUILT'];
    
    // Rileva se il testo Ã¨ inglese
    function isEnglish(str) {
        const upperStr = str.toUpperCase();
        const words = upperStr.split(/[\s\\\.,!?;\-]+/).filter(w => w.length >= 2);
        
        // Conta quante parole inglesi comuni ci sono
        let englishCount = 0;
        for (let word of words) {
            if (englishWords.includes(word)) englishCount++;
        }
        
        // Se almeno 25% delle parole sono inglesi comuni, Ã¨ inglese
        return words.length > 0 && englishCount >= Math.max(1, words.length * 0.25);
    }
    
    let rom = null;
    let scanResults = [];
    let uniqueStrings = new Set();
    let repointedOffsets = new Set(); // Traccia offset repointed per skipparli in scansione
    let romExpansions = 0; // Conta quante volte espandiamo la ROM

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUTOSAVE SYSTEM con IndexedDB
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const AUTOSAVE_KEY = 'gba_patch_state';
    const AUTOSAVE_INTERVAL = 10;
    const DB_NAME = 'GBATranslatorDB';
    const DB_VERSION = 1;
    let db = null;

    // Inizializza IndexedDB
    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                db = request.result;
                resolve(db);
            };
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('files')) {
                    db.createObjectStore('files', { keyPath: 'id' });
                }
            };
        });
    }

    // Salva ROM in IndexedDB
    async function saveROM(romData) {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readwrite');
            const store = tx.objectStore('files');
            const request = store.put({ id: 'rom', data: romData, timestamp: Date.now() });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    // Carica ROM da IndexedDB
    async function loadROM() {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readonly');
            const store = tx.objectStore('files');
            const request = store.get('rom');
            request.onsuccess = () => resolve(request.result?.data || null);
            request.onerror = () => reject(request.error);
        });
    }

    // Salva file TXT in IndexedDB
    async function saveTxtContent(content) {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readwrite');
            const store = tx.objectStore('files');
            const request = store.put({ id: 'txt', data: content, timestamp: Date.now() });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
    }

    // Carica file TXT da IndexedDB
    async function loadTxtContent() {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(['files'], 'readonly');
            const store = tx.objectStore('files');
            const request = store.get('txt');
            request.onsuccess = () => resolve(request.result?.data || null);
            request.onerror = () => reject(request.error);
        });
    }

    // Salva stato patch
    function saveState(idx, stats, lines) {
        const state = {
            timestamp: Date.now(),
            lastIndex: idx,
            stats: stats,
            totalLines: lines.length,
            repointedOffsets: Array.from(repointedOffsets) // Salva offset repointed
        };
        localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(state));
    }

    // Carica stato patch
    function loadState() {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        if (saved) {
            const state = JSON.parse(saved);
            // Ripristina offset repointed
            if (state.repointedOffsets) {
                repointedOffsets = new Set(state.repointedOffsets);
            }
            return state;
        }
        return null;
    }

    // Cancella tutto
    async function clearState() {
        localStorage.removeItem(AUTOSAVE_KEY);
        repointedOffsets.clear(); // Reset memoria repoint
        if (db) {
            const tx = db.transaction(['files'], 'readwrite');
            const store = tx.objectStore('files');
            store.delete('rom');
            store.delete('txt');
        }
    }

    // Check resume al caricamento
    window.addEventListener('load', async () => {
        await initDB();
        const state = loadState();
        if (state && Date.now() - state.timestamp < 24*60*60*1000) {
            const elapsed = Math.floor((Date.now() - state.timestamp) / 60000);
            document.getElementById('resumeText').textContent = 
                `Trovato salvataggio da ${elapsed < 1 ? '<1' : elapsed} minuti fa.\nProcessate ${state.lastIndex}/${state.totalLines} stringhe.\n\nROM e file TXT salvati automaticamente.`;
            document.getElementById('resumeModal').classList.add('active');
        }
        
        // Aggiorna UI memoria repoint
        updateRepointMemoryUI();
    });

    // Cancella e ricomincia
    async function clearResume() {
        await clearState();
        document.getElementById('resumeModal').classList.remove('active');
        toast('Stato cancellato', 'success');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const log = (m, type = 'info') => {
        const l = document.getElementById('log');
        const cls = type === 'success' ? 'log-success' : type === 'error' ? 'log-error' : type === 'warning' ? 'log-warning' : '';
        l.innerHTML += `<span class="${cls}">${m}</span><br>`;
        l.scrollTop = l.scrollHeight;
    };

    const toast = (msg, type = 'success') => {
        const t = document.createElement('div');
        t.className = `toast ${type}`;
        t.textContent = msg;
        document.body.appendChild(t);
        setTimeout(() => t.remove(), 2500);
    };

    document.getElementById('romFile').onchange = function(e) {
        const reader = new FileReader();
        reader.onload = async () => {
            rom = new Uint8Array(reader.result);
            const mb = (rom.length / 1024 / 1024).toFixed(1);
            const info = document.getElementById('romInfo');
            info.innerHTML = `âœ… ${e.target.files[0].name} (${mb} MB)`;
            log('ROM caricata', 'success');
            
            // Salva ROM in IndexedDB per resume automatico
            try {
                await saveROM(rom);
                info.innerHTML = `âœ… ${e.target.files[0].name} (${mb} MB) ğŸ’¾ <span style="color:var(--success)">Salvata per resume</span>`;
                info.classList.add('saved');
                log('ROM salvata per resume automatico', 'success');
            } catch(err) {
                log('Avviso: ROM non salvata (spazio disco pieno?)', 'warning');
            }
        };
        reader.readAsArrayBuffer(this.files[0]);
    };

    function countSyllables(str) {
        str = str.toUpperCase();
        let count = 0;
        for (let syl of validSyllables) {
            let pos = 0;
            while ((pos = str.indexOf(syl, pos)) !== -1) {
                count++;
                pos += syl.length;
            }
        }
        return count;
    }

    function isValidText(str, mode) {
        if (!str || str.length < 3) return false;

        // MODALITÃ€ ALL - Accetta quasi tutto
        if (mode === 'all') {
            // Solo filtri anti-garbage estremi
            if (str.length < 3) return false;
            
            // Deve avere almeno QUALCHE lettera
            if (!/[A-Za-z]/.test(str)) return false;
            
            // Anti-encoding corrotto estremo
            const accentCount = (str.match(/[Ã€-Ã¿]/g) || []).length;
            const normalLetters = (str.match(/[A-Za-z]/g) || []).length;
            if (normalLetters > 0 && accentCount > normalLetters * 0.5) return false;
            
            // Anti-pattern grafici totali
            if (/[Ã€-Ã¿]{3,}/.test(str)) return false;
            if (/(.)\1{6,}/.test(str)) return false; // 7+ ripetizioni
            
            return true;
        }

        // DIALOGHI - FILTRO LEGGERO
        if (mode === 'dialogs') {
            // Lunghezza minima RIDOTTA
            if (str.length < 10) return false; // Era 15
            
            // Accetta dialoghi CON o SENZA marcatori se abbastanza lunghi
            const hasMarkers = str.includes('\\n') || str.includes('\\p') || str.includes('\\l');
            if (!hasMarkers && str.length < 20) return false;
            
            // Anti-ripetizioni base
            if (/(.)\1{5,}/.test(str)) return false; // 6+ lettere uguali
            
            // Anti-encoding corrotto (piÃ¹ permissivo)
            const accentCount = (str.match(/[Ã€-Ã¿]/g) || []).length;
            const normalLetters = (str.match(/[A-Za-z]/g) || []).length;
            if (normalLetters > 0 && accentCount > normalLetters * 0.25) return false; // Era 0.15
            
            // Anti-glitch pattern base
            if (/[Ã€-Ã¿]{3,}/.test(str)) return false;
            if (/[Ã‹Ãƒ]{2,}/.test(str)) return false;
            
            // Vocali minime
            const vowelCount = (str.match(/[AEIOUaeiou]/g) || []).length;
            if (normalLetters > 5 && vowelCount < normalLetters * 0.20) return false; // Era 0.25
            
            // Almeno 1 parola di 3+ lettere
            const words = str.split(/[\s\\,!?.;:\-]/);
            const hasWord = words.some(w => /^[A-Za-z]{3,}$/.test(w));
            if (!hasWord) return false;
            
            return true;
        }

        // MOSSE/OGGETTI - Filtro stringente
        if (mode === 'short') {
            if (str.length < 3 || str.length > 20) return false; // Era max 18
            if (str !== str.toUpperCase()) return false;
            if (str.includes('\\')) return false;
            if (/  +/.test(str) || str.startsWith(' ') || str.endsWith(' ')) return false;
            if (/[^A-Z0-9 \.\!\?\-']/.test(str)) return false;
            
            const cleanStr = str.replace(/[^A-Z]/g, '');
            if (blockedSounds.includes(cleanStr)) return false;
            if (str.split(' ').some(word => blockedSounds.includes(word))) return false;
            
            if (!/[AEIOU]/.test(str)) return false;
            if (/(.)\1{1,}/.test(str.replace(/[^A-Z]/g, ''))) return false;
            
            const vowels = (str.match(/[AEIOU]/g) || []).length;
            const letters = (str.match(/[A-Z]/g) || []).length;
            if (letters > 0 && vowels < letters * 0.25) return false; // Era 0.30
            
            if (/[BCDFGHJKLMNPQRSTVWXYZ]{4,}/.test(str)) return false;
            
            for (let i = 0; i < str.length - 2; i++) {
                const c1 = str.charCodeAt(i);
                const c2 = str.charCodeAt(i + 1);
                const c3 = str.charCodeAt(i + 2);
                if (c2 === c1 + 1 && c3 === c2 + 1) return false;
            }
            
            const syllableCount = countSyllables(str);
            if (syllableCount < 1) { // Era 2
                if (!knownWords.includes(str.replace(/[^A-Z]/g, ''))) return false;
            }
            
            const rareLetters = (str.match(/[QXZJKW]/g) || []).length;
            if (rareLetters > letters * 0.4) return false;
            if (/^[0-9\.\-\s]+$/.test(str)) return false;
            
            return true;
        }
        return false;
    }

    // Aggiorna UI memoria repoint
    function updateRepointMemoryUI() {
        const memoryDiv = document.getElementById('repointMemory');
        const countSpan = document.getElementById('repointCount');
        
        if (repointedOffsets.size > 0) {
            memoryDiv.style.display = 'block';
            countSpan.textContent = repointedOffsets.size;
        } else {
            memoryDiv.style.display = 'none';
        }
    }

    // Cancella memoria repoint
    function clearRepointMemory() {
        if (confirm(`Cancellare ${repointedOffsets.size} offset dalla memoria?\n\nQuesti offset non verranno piÃ¹ skippati durante la scansione.`)) {
            repointedOffsets.clear();
            updateRepointMemoryUI();
            toast('Memoria cancellata', 'success');
            log('ğŸ—‘ï¸ Memoria repoint cancellata', 'info');
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCAN
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function scan() {
        if(!rom) return toast('Carica ROM prima!', 'error');
        
        const mode = document.getElementById('extractMode').value;
        const englishOnly = document.getElementById('englishOnly').checked;
        const body = document.getElementById('resBody');
        body.innerHTML = "";
        scanResults = [];
        uniqueStrings.clear();
        
        const wrap = document.getElementById('scanProgress');
        const fill = document.getElementById('scanFill');
        const pct = document.getElementById('scanPct');
        const status = document.getElementById('scanStatus');
        wrap.classList.add('active');
        fill.style.width = '0%';
        
        log(`Scansione ${mode} avviata${englishOnly ? ' (SOLO inglese)' : ''}`, 'info');
        
        if (repointedOffsets.size > 0) {
            log(`ğŸ§  Memoria: ${repointedOffsets.size} offset repointed verranno skippati`, 'info');
        }

        const START = 0x200000, END = rom.length;
        let i = START, count = 0, rejected = 0, rejectedLang = 0;

        function update() {
            const p = Math.min(100, ((i - START) / (END - START)) * 100);
            fill.style.width = p.toFixed(1) + '%';
            pct.textContent = p.toFixed(0) + '%';
            status.textContent = `0x${i.toString(16).toUpperCase()} â€” ${count} trovate${englishOnly ? ` | ${rejectedLang} non-inglese` : ''}`;
        }

        function doScan() {
            let limit = Math.min(i + 0x50000, END);
            for(; i < limit; i++) {
                if(rom[i] >= 0xBB && rom[i] <= 0xD4) {
                    const currentOffset = i;
                    let s = "", j = i;
                    while(j < rom.length && rom[j] !== 0xFF && s.length < 500) {
                        s += charMap[rom[j]] || '';
                        j++;
                    }
                    
                    // Skippa stringhe vuote o cancellate
                    if (!s || s.trim().length === 0) {
                        rejected++;
                        continue;
                    }
                    
                    // SKIPPA se offset Ã¨ stato repointed (memoria persistente)
                    if (repointedOffsets.has(currentOffset)) {
                        rejected++;
                        continue;
                    }

                    if(isValidText(s, mode) && !uniqueStrings.has(s)) {
                        // Filtro lingua se richiesto
                        if (englishOnly && !isEnglish(s)) {
                            rejectedLang++;
                            continue;
                        }
                        
                        uniqueStrings.add(s);
                        const off = "0x" + i.toString(16).toUpperCase();
                        const lang = isEnglish(s) ? 'ğŸ‡¬ğŸ‡§' : 'ğŸ‡®ğŸ‡¹';
                        
                        // Salva SENZA tag nel risultato
                        scanResults.push({o: off, t: s, b: j - i, lang: lang});
                        
                        // Mostra CON tag nella tabella
                        if(count < 200) {
                            body.insertAdjacentHTML('beforeend', 
                                `<tr><td class="hex">${off}</td><td>${j-i}</td><td class="text-cell">${lang} ${s}</td></tr>`);
                        }
                        count++;
                        i = j;
                    } else rejected++;
                }
            }
            
            update();
            document.getElementById('stats').textContent = `âœ… ${count} | ğŸš« ${rejected}${englishOnly ? ` | ğŸ‡®ğŸ‡¹ ${rejectedLang}` : ''}`;
            
            if(i < END - 1) requestAnimationFrame(doScan);
            else {
                fill.style.width = '100%';
                pct.textContent = '100%';
                status.textContent = `âœ… ${count} stringhe${englishOnly ? ' inglesi' : ''} trovate`;
                log(`Completata: ${count} valide${englishOnly ? ` (${rejectedLang} non-inglesi escluse)` : ''}`, 'success');
                toast(`${count} stringhe trovate`, 'success');
                setTimeout(() => wrap.classList.remove('active'), 3000);
            }
        }
        doScan();
    }

    function exportTxt() {
        if(!scanResults.length) return toast('Niente da esportare', 'error');
        let out = "OFFSET | MAX_BYTE | TESTO\n";
        scanResults.forEach(r => {
            // NON includere tag lingua nel file - servono solo per visualizzazione
            out += `${r.o} | ${r.b} | ${r.t}\n`;
        });
        
        // UTF-8 BOM per compatibilitÃ 
        const BOM = '\uFEFF';
        const blob = new Blob([BOM + out], {type:'text/plain;charset=utf-8'});
        
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const mode = document.getElementById('extractMode').value;
        const englishOnly = document.getElementById('englishOnly').checked;
        a.download = `Trad_${mode}${englishOnly ? '_EN' : ''}_${Date.now()}.txt`;
        a.click();
        log('File esportato', 'success');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PATCH con AUTOSAVE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function textToBytes(text) {
        let bytes = [];
        for (let k = 0; k < text.length; k++) {
            if (text[k] === '\\' && text[k + 1]) {
                let code = text[k] + text[k + 1];
                if (invMap[code] !== undefined) { 
                    bytes.push(invMap[code]); 
                    k++; 
                    continue; 
                }
            }
            
            const char = text[k];
            if (invMap[char] !== undefined) {
                bytes.push(invMap[char]);
            } else {
                // Carattere non mappato - SKIPPA (emoji, simboli strani, ecc.)
                // NON scrivere 0x00 per caratteri sconosciuti
                continue;
            }
        }
        bytes.push(0xFF); // Terminatore
        return bytes;
    }

    function findFreeSpace(needed) {
        let count = 0;
        for (let i = rom.length - 1; i > 0x800000; i--) {
            if (rom[i] === 0xFF) count++;
            else count = 0;
            if (count >= needed + 10) return i + 5;
        }
        
        // ESPANSIONE AUTOMATICA - Se non c'Ã¨ spazio, allarga la ROM!
        const expandBy = Math.max(needed + 0x10000, 0x100000); // Aggiungi almeno 1MB
        const oldSize = rom.length;
        const newSize = oldSize + expandBy;
        
        romExpansions++; // Conta espansione
        log(`ğŸ“ˆ Espansione ROM #${romExpansions}: ${(oldSize / 1024 / 1024).toFixed(1)}MB â†’ ${(newSize / 1024 / 1024).toFixed(1)}MB (+${(expandBy / 1024).toFixed(0)}KB)`, 'info');
        
        const newRom = new Uint8Array(newSize);
        newRom.set(rom); // Copia vecchia ROM
        newRom.fill(0xFF, oldSize); // Riempi nuovo spazio con 0xFF
        rom = newRom;
        
        // Ritorna offset nel nuovo spazio
        return oldSize + 5;
    }

    function createPointer(offset) {
        return new Uint8Array([offset & 0xFF, (offset >> 8) & 0xFF, (offset >> 16) & 0xFF, 0x08]);
    }

    function repointPointers(oldOff, newOff) {
        const oldPtr = createPointer(oldOff);
        const newPtr = createPointer(newOff);
        let found = 0;
        
        // Scansiona TUTTA la ROM (non solo da 0x0)
        // I puntatori possono essere ovunque, anche all'inizio
        for (let i = 0; i < rom.length - 4; i++) {
            if (rom[i] === oldPtr[0] && 
                rom[i+1] === oldPtr[1] && 
                rom[i+2] === oldPtr[2] && 
                rom[i+3] === oldPtr[3]) {
                rom.set(newPtr, i);
                found++;
            }
        }
        
        // Se non trovato nessun puntatore, prova pattern alternativi
        if (found === 0) {
            // Cerca offset senza byte 0x08 (alcuni giochi usano offset diretti)
            const offset3Bytes = new Uint8Array([oldOff & 0xFF, (oldOff >> 8) & 0xFF, (oldOff >> 16) & 0xFF]);
            for (let i = 0; i < rom.length - 3; i++) {
                if (rom[i] === offset3Bytes[0] && 
                    rom[i+1] === offset3Bytes[1] && 
                    rom[i+2] === offset3Bytes[2]) {
                    // Verifica che non sia un falso positivo
                    if (i < 4 || rom[i-1] !== 0x08) { // Non Ã¨ giÃ  un puntatore completo
                        const new3Bytes = new Uint8Array([newOff & 0xFF, (newOff >> 8) & 0xFF, (newOff >> 16) & 0xFF]);
                        rom.set(new3Bytes, i);
                        found++;
                    }
                }
            }
        }
        
        return found;
    }

    async function patch() {
        const file = document.getElementById('txtFile').files[0];
        if (!file || !rom) return toast('ROM o TXT mancante', 'error');

        const txtContent = await file.text();
        
        // RILEVA SE Ãˆ UN FILE SHORT (mosse/oggetti/abilitÃ )
        const lines = txtContent.split('\n').slice(1, 20); // Prendi prime 20 righe
        let shortCount = 0;
        for (let line of lines) {
            const parts = line.split('|');
            if (parts.length >= 3) {
                const text = parts[2].trim().replace(/^\[[ğŸ‡¬ğŸ‡§ğŸ‡®ğŸ‡¹]+\]\s*/, '');
                // Se il testo Ã¨ tutto maiuscolo e corto, Ã¨ probabilmente SHORT
                if (text === text.toUpperCase() && text.length < 25 && !text.includes('\\n')) {
                    shortCount++;
                }
            }
        }
        
        const isShortFile = shortCount > 10; // Se piÃ¹ di 10 su 20 sono SHORT
        
        if (isShortFile) {
            const confirm = window.confirm(
                'âš ï¸ FILE SHORT RILEVATO\n\n' +
                'Strategia: SPOSTA TUTTO\n' +
                'â€¢ Tutte le stringhe â†’ spazio libero ğŸ”€\n' +
                'â€¢ Tutto l\'inglese â†’ cancellato ğŸ—‘ï¸\n' +
                'â€¢ ROM â†’ espansa se serve ğŸ“ˆ\n' +
                'â€¢ Errori â†’ ZERO garantiti âœ…\n\n' +
                'La ROM diventerÃ  piÃ¹ grande ma TUTTO in italiano!\n\n' +
                'Vuoi procedere?'
            );
            
            if (!confirm) {
                toast('Patch annullata', 'warning');
                return;
            }
            
            log('ğŸ”€ Strategia SPOSTA TUTTO attivata - ROM puÃ² espandersi', 'info');
        }
        
        // Salva file TXT in IndexedDB per resume
        try {
            await saveTxtContent(txtContent);
            log('âœ… File TXT salvato per resume automatico', 'success');
            toast('ğŸ’¾ ROM e TXT salvati - patch protetta', 'success');
        } catch(err) {
            log('Avviso: TXT non salvato', 'warning');
        }

        await doPatch(txtContent, 0);
    }

    async function resumePatch() {
        document.getElementById('resumeModal').classList.remove('active');
        
        log('â³ Ripristino dati salvati...', 'info');
        toast('ğŸ”„ Caricamento dati...', 'info');
        
        // Carica ROM da IndexedDB
        const savedROM = await loadROM();
        if (!savedROM) {
            toast('âŒ ROM non trovata! Ricaricala manualmente', 'error');
            log('ROM non trovata in memoria', 'error');
            return;
        }
        rom = savedROM;
        const mb = (rom.length / 1024 / 1024).toFixed(1);
        const info = document.getElementById('romInfo');
        info.innerHTML = `âœ… ROM ripristinata (${mb} MB) ğŸ’¾ <span style="color:var(--success)">Da memoria</span>`;
        info.classList.add('saved');
        log('âœ… ROM caricata automaticamente', 'success');
        
        // Carica file TXT da IndexedDB
        const txtContent = await loadTxtContent();
        if (!txtContent) {
            toast('âŒ File TXT non trovato! Ricaricalo manualmente', 'error');
            log('File TXT non trovato in memoria', 'error');
            return;
        }
        log('âœ… File TXT caricato automaticamente', 'success');
        
        // Carica stato
        const state = loadState();
        if (!state) {
            toast('Stato non trovato', 'error');
            return;
        }
        
        log(`ğŸ”„ Ripresa da riga ${state.lastIndex}/${state.totalLines}`, 'success');
        toast('ğŸš€ Patch ripresa automaticamente!', 'success');
        
        // Riprendi patch da dove si era fermata
        await doPatch(txtContent, state.lastIndex, state.stats);
    }

    async function doPatch(txtContent, startIdx = 0, savedStats = null) {
        const btn = document.getElementById('patchBtn');
        btn.disabled = true;
        
        romExpansions = 0; // Reset contatore espansioni

        const wrap = document.getElementById('patchProgress');
        const fill = document.getElementById('patchFill');
        const pct = document.getElementById('patchPct');
        const status = document.getElementById('patchStatus');
        wrap.classList.add('active');
        fill.style.width = '0%';

        const lines = txtContent.split('\n').filter(l => l.includes('|') && !l.startsWith('OFFSET'));
        const total = lines.length;
        
        let idx = startIdx;
        let stats = savedStats || { total: 0, repointed: 0, failed: 0, protected: 0, noPointers: 0, truncated: 0, deleted: 0, expanded: 0 };

        log(`Patch ${startIdx > 0 ? 'ripresa' : 'avviata'} da riga ${idx}/${total}`);
        document.getElementById('patchReport').innerHTML = '';

        function processChunk() {
            const chunkEnd = Math.min(idx + 20, total);

            for (; idx < chunkEnd; idx++) {
                const parts = lines[idx].split('|').map(s => s.trim());
                if (parts.length < 3) continue;

                const [offStr, maxBStr, textRaw] = parts;
                
                // Rimuovi tag lingua in modo piÃ¹ robusto
                let text = textRaw
                    .replace(/^\[ğŸ‡¬ğŸ‡§\]\s*/g, '')
                    .replace(/^\[ğŸ‡®ğŸ‡¹\]\s*/g, '')
                    .replace(/^\[[^\]]+\]\s*/g, ''); // Fallback per altri tag
                
                const oldOff = parseInt(offStr, 16);
                const maxB = parseInt(maxBStr);

                if (isNaN(oldOff) || oldOff < 0x200000) {
                    stats.protected++;
                    continue;
                }

                stats.total++;
                const newBytes = textToBytes(text);
                const forceOverwrite = document.getElementById('forceOverwrite').checked;

                try {
                    // STRATEGIA: Sposta TUTTO nello spazio libero (zero inglese residuo)
                    // Eccezione: se forceOverwrite Ã¨ attivo E la stringa Ã¨ troppo lunga â†’ tronca
                    
                    if (forceOverwrite && newBytes.length > maxB + 1) {
                        // CASO 1: Force overwrite attivo + stringa troppo lunga = TRONCA
                        const truncated = newBytes.slice(0, maxB);
                        truncated.push(0xFF);
                        rom.set(truncated, oldOff);
                        stats.truncated++;
                    } else {
                        // CASO 2: Sposta SEMPRE (anche se entra in loco)
                        const newOff = findFreeSpace(newBytes.length);
                        // findFreeSpace NON puÃ² piÃ¹ fallire (espande automaticamente)
                        
                        // Scrivi nuova stringa nello spazio libero
                        rom.set(newBytes, newOff);
                        
                        // CANCELLA SEMPRE la vecchia stringa (tutto inglese via!)
                        const oldLen = maxB + 1;
                        rom.set(new Uint8Array(oldLen).fill(0xFF), oldOff);
                        stats.deleted++;
                        repointedOffsets.add(oldOff);
                        
                        // PROVA a trovare e aggiornare puntatori
                        const ptrCount = repointPointers(oldOff, newOff);
                        stats.repointed++;
                        
                        if (ptrCount === 0) {
                            stats.noPointers++;
                        }
                    }
                } catch(e) {
                    stats.failed++;
                    log(`âŒ ${offStr}: ${e.message}`, 'error');
                }

                // AUTOSAVE ogni 10 stringhe
                if ((idx + 1) % AUTOSAVE_INTERVAL === 0) {
                    saveState(idx + 1, stats, lines);
                }
            }

            const p = total > 0 ? Math.min(100, (idx / total) * 100) : 100;
            fill.style.width = p.toFixed(1) + '%';
            pct.textContent = p.toFixed(0) + '%';
            status.textContent = `${idx}/${total} â€” âœ…${stats.overwritten} ğŸ”€${stats.repointed} âŒ${stats.failed}`;

            if (idx < total) {
                requestAnimationFrame(processChunk);
            } else {
                // FINE
                clearState();
                fill.style.width = '100%';
                pct.textContent = '100%';
                status.textContent = 'âœ… Completata!';
                
                stats.expanded = romExpansions; // Salva contatore espansioni

                const truncPercent = stats.truncated > 0 ? Math.round((stats.truncated / stats.total) * 100) : 0;
                
                document.getElementById('patchReport').innerHTML = `
                    <div class="report">
                        <div class="report-item"><span>Processate</span><strong>${stats.total}</strong></div>
                        <div class="report-item"><span>ğŸ”€ Spostate</span><strong style="color:var(--accent)">${stats.repointed}</strong></div>
                        <div class="report-item"><span>ğŸ—‘ï¸ Cancellate</span><strong style="color:var(--success)">${stats.deleted}</strong></div>
                        ${stats.noPointers > 0 ? `<div class="report-item"><span>âš ï¸ Senza ptr</span><strong style="color:var(--warning)">${stats.noPointers}</strong></div>` : ''}
                        ${stats.truncated > 0 ? `<div class="report-item"><span>âœ‚ï¸ Troncate</span><strong style="color:var(--warning)">${stats.truncated} (${truncPercent}%)</strong></div>` : ''}
                        ${stats.expanded > 0 ? `<div class="report-item"><span>ğŸ“ˆ Espansioni ROM</span><strong style="color:var(--accent)">${stats.expanded}</strong></div>` : ''}
                        <div class="report-item"><span>ğŸ›¡ï¸ Protette</span><strong style="color:var(--text-dim)">${stats.protected}</strong></div>
                        ${stats.failed > 0 ? `<div class="report-item"><span>âŒ Fallite</span><strong style="color:var(--danger)">${stats.failed}</strong></div>` : ''}
                    </div>`;

                log(`âœ… Patch completata: ${stats.repointed}/${stats.total}`, 'success');
                
                if (stats.deleted > 0) {
                    log(`ğŸ—‘ï¸ ${stats.deleted} stringhe inglesi cancellate completamente`, 'success');
                    log(`ğŸ§  ${repointedOffsets.size} offset salvati in memoria persistente`, 'info');
                }
                
                if (stats.expanded > 0) {
                    const finalSize = (rom.length / 1024 / 1024).toFixed(1);
                    log(`ğŸ“ˆ ROM espansa ${stats.expanded} volte - Dimensione finale: ${finalSize}MB`, 'info');
                }
                
                if (stats.noPointers > 0) {
                    log(`âš ï¸ ${stats.noPointers} stringhe senza puntatori (potrebbero rimanere inglesi se gioco usa offset fissi)`, 'warning');
                }
                
                updateRepointMemoryUI(); // Aggiorna UI memoria
                
                if (stats.truncated > 0) {
                    const truncPercent = Math.round((stats.truncated / stats.total) * 100);
                    log(`âœ‚ï¸ ${stats.truncated} stringhe troncate manualmente (${truncPercent}%)`, 'warning');
                }

                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([rom], {type:'application/octet-stream'}));
                a.download = 'Pokemon_ITA.gba';
                a.click();

                toast('ROM patchata scaricata', 'success');
                btn.disabled = false;
            }
        }

        processChunk();
    }
</script>
</body>
</html>

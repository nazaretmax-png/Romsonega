<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GBA Rom Translator - Ultra AI Filter</title>
    <style>
        :root { --bg: #0d1117; --card: #161b22; --accent: #ff7b72; --btn: #238636; --text: #c9d1d9; --border: #30363d; }
        body { font-family: -apple-system, sans-serif; background: var(--bg); color: var(--text); padding: 15px; margin: 0; }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { text-align: center; color: var(--accent); font-size: 1.6rem; margin-bottom: 20px; }
        .card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 20px; margin-bottom: 15px; }
        select, button, input { width: 100%; padding: 12px; margin: 8px 0; border-radius: 6px; border: 1px solid var(--border); background: #0d1117; color: white; font-size: 15px; }
        button { background: var(--accent); border: none; font-weight: bold; color: #0d1117; cursor: pointer; }
        button:hover { opacity: 0.9; }
        .btn-green { background: var(--btn); color: white; }
        .log-box { background: #010409; height: 100px; border: 1px solid var(--border); border-radius: 6px; padding: 10px; overflow-y: auto; font-family: monospace; font-size: 12px; color: #8b949e; }
        .preview-box { height: 350px; background: #010409; border: 1px solid var(--border); border-radius: 6px; overflow-y: auto; margin-top: 10px; }
        table { width: 100%; border-collapse: collapse; font-size: 13px; font-family: monospace; }
        th { background: #161b22; color: var(--accent); padding: 8px; text-align: left; position: sticky; top: 0; }
        td { padding: 8px; border-bottom: 1px solid var(--border); }
        .hex { color: #d2a8ff; font-weight: bold; }
    </style>
</head>
<body>

<div class="container">
    <h1>GBA Translator üß† (AI Filter Mode)</h1>

    <div class="card">
        <h3>1. File ROM (.gba)</h3>
        <input type="file" id="romFile" accept=".gba">
        <div id="romName" style="font-size: 12px; color: #8b949e;">Attesa ROM...</div>
    </div>

    <div class="card">
        <h3>2. Estrazione Senza Duplicati</h3>
        <select id="extractMode">
            <option value="short">‚öîÔ∏è Mosse/Oggetti/Nomi (Niente doppioni)</option>
            <option value="dialogs">üí¨ Dialoghi Veri (Solo testo umano)</option>
        </select>
        <button onclick="smartScan()">Avvia Scansione Perfetta</button>
        
        <div class="preview-box">
            <table>
                <thead><tr><th>Offset</th><th>Max Byte</th><th>Testo Unico</th></tr></thead>
                <tbody id="resBody"></tbody>
            </table>
        </div>
        <button style="background:transparent; border:1px solid var(--accent); color:var(--accent); margin-top:10px;" onclick="exportTxt()">üíæ Scarica File TXT</button>
    </div>

    <div class="card">
        <h3>3. Patch & Repoint</h3>
        <input type="file" id="txtFile" accept=".txt">
        <button class="btn-green" onclick="applyPatch()">‚ö° Applica Traduzione alla ROM</button>
    </div>

    <div class="log-box" id="log">Pronto...</div>
</div>

<script>
    const charMap = { 0x00: ' ', 0x01: '√Ä', 0x02: '√Å', 0x03: '√Ç', 0x04: '√á', 0x05: '√à', 0x06: '√â', 0x07: '√ä', 0x08: '√ã', 0x09: '√å', 0x0B: '√é', 0x0C: '√è', 0x0D: '√í', 0x0E: '√ì', 0x0F: '√î', 0x10: '≈í', 0x11: '√ô', 0x12: '√ö', 0x13: '√õ', 0x14: '≈∏', 0x15: '√ü', 0x16: '√†', 0x17: '√°', 0x19: '√ß', 0x1A: '√®', 0x1B: '√©', 0x1C: '√™', 0x1D: '√´', 0x1E: '√¨', 0x20: '√Æ', 0x21: '√Ø', 0x22: '√≤', 0x23: '√≥', 0x24: '√¥', 0x25: '≈ì', 0x26: '√π', 0x27: '√∫', 0x28: '√ª', 0x29: '√ø', 0x2D: '&', 0x2E: '+', 0xAB: '!', 0xAC: '?', 0xAD: '.', 0xAE: '-', 0xB0: '...', 0xB8: ',', 0xBB: 'A', 0xBC: 'B', 0xBD: 'C', 0xBE: 'D', 0xBF: 'E', 0xC0: 'F', 0xC1: 'G', 0xC2: 'H', 0xC3: 'I', 0xC4: 'J', 0xC5: 'K', 0xC6: 'L', 0xC7: 'M', 0xC8: 'N', 0xC9: 'O', 0xCA: 'P', 0xCB: 'Q', 0xCC: 'R', 0xCD: 'S', 0xCE: 'T', 0xCF: 'U', 0xD0: 'V', 0xD1: 'W', 0xD2: 'X', 0xD3: 'Y', 0xD4: 'Z', 0xD5: 'a', 0xD6: 'b', 0xD7: 'c', 0xD8: 'd', 0xD9: 'e', 0xDA: 'f', 0xDB: 'g', 0xDC: 'h', 0xDD: 'i', 0xDE: 'j', 0xDF: 'k', 0xE0: 'l', 0xE1: 'm', 0xE2: 'n', 0xE3: 'o', 0xE4: 'p', 0xE5: 'q', 0xE6: 'r', 0xE7: 's', 0xE8: 't', 0xE9: 'u', 0xEA: 'v', 0xEB: 'w', 0xEC: 'x', 0xED: 'y', 0xEE: 'z', 0xFA: '\\l', 0xFB: '\\p', 0xFD: '\\v', 0xFE: '\\n' };
    const invMap = Object.fromEntries(Object.entries(charMap).map(([k,v]) => [v, parseInt(k)]));
    
    let rom = null;
    let scanResults = [];
    let uniqueStrings = new Set(); // IL DISTRUTTORE DI DUPLICATI

    const log = (m) => { const l = document.getElementById('log'); l.innerHTML += `> ${m}<br>`; l.scrollTop = l.scrollHeight; };

    document.getElementById('romFile').onchange = function(e) {
        const reader = new FileReader();
        reader.onload = () => { rom = new Uint8Array(reader.result); document.getElementById('romName').innerText = "ROM: " + e.target.files[0].name; log("ROM Caricata. Pronta per l'analisi."); };
        reader.readAsArrayBuffer(this.files[0]);
    };

    function isValidText(str, mode) {
        if (!str || str.length < 3) return false;

        if (mode === 'dialogs') {
            // LUNGHEZZA MINIMA
            if (str.length < 15) return false;
            
            // DEVE AVERE MARCATORI DI DIALOGO
            if (!str.includes('\\n') && !str.includes('\\p') && !str.includes('\\l')) return false;
            
            // REGOLA "TESTO UMANO": Un dialogo lungo senza spazi √® grafica compressa
            const spaceCount = (str.match(/ /g) || []).length;
            if (str.length > 25 && spaceCount < 2) return false;
            
            // REGOLA "ANTI-ENCODING CORROTTO": Se ci sono troppi caratteri accentati √® corrotto
            const accentCount = (str.match(/[√Ä-√ø]/g) || []).length;
            const normalLetters = (str.match(/[A-Za-z]/g) || []).length;
            if (accentCount > normalLetters * 0.3) return false; // Max 30% di accenti
            
            // REGOLA "ANTI-GLITCH POTENZIATA": Blocca pattern di caratteri strani
            if (/[√Ä-√ø\^~#@]{2,}/.test(str)) return false; // 2+ caratteri strani consecutivi
            if (/[√ã√É]{2,}/.test(str)) return false; // Pattern tipico di encoding corrotto
            
            // REGOLA "TESTO SENSATO": Deve avere almeno una parola di 4+ lettere
            const words = str.split(/[\s\\]/);
            const hasRealWord = words.some(w => /^[A-Za-z]{4,}$/.test(w));
            if (!hasRealWord) return false;
            
            return true;
        }

        if (mode === 'short') {
            // LUNGHEZZA MASSIMA
            if (str.length > 18) return false;
            
            // DEVE ESSERE TUTTO MAIUSCOLO
            if (str !== str.toUpperCase()) return false; 
            
            // NO MARCATORI DI DIALOGO
            if (str.includes('\\')) return false; 
            
            // REGOLA "PAROLA VERA": Deve avere almeno 3 lettere consecutive
            if (!/[A-Z]{3,}/.test(str)) return false;
            
            // REGOLA "NO CARATTERI STRANI"
            if (/[^A-Z0-9 \.\!\?\-']/.test(str)) return false;
            
            // REGOLA "VOCALI OBBLIGATORIE": Le parole vere hanno vocali!
            // Questo blocca "FFFF", "ZZZZZ", "BCX", "KYS", ecc.
            const hasVowel = /[AEIOU]/.test(str);
            if (!hasVowel) return false;
            
            // REGOLA "ANTI-RIPETIZIONE": Non pi√π di 3 lettere uguali consecutive
            // Blocca "FFFFF", "AAAAA", ecc.
            if (/(.)\1{3,}/.test(str)) return false;
            
            // REGOLA "DENSIT√Ä VOCALE": Deve avere almeno 1 vocale ogni 4 lettere
            const vowelCount = (str.match(/[AEIOU]/g) || []).length;
            const letterCount = (str.match(/[A-Z]/g) || []).length;
            if (letterCount > 3 && vowelCount < letterCount / 4) return false;
            
            // REGOLA "NO SEQUENZE ALFABETICHE": Blocca "ABCDE", "FGHIJ", ecc.
            for (let i = 0; i < str.length - 2; i++) {
                const c1 = str.charCodeAt(i);
                const c2 = str.charCodeAt(i + 1);
                const c3 = str.charCodeAt(i + 2);
                if (c2 === c1 + 1 && c3 === c2 + 1) {
                    return false; // 3+ lettere consecutive nell'alfabeto
                }
            }
            
            return true;
        }
        return false;
    }

    function smartScan() {
        if(!rom) return alert("Carica la ROM!");
        const mode = document.getElementById('extractMode').value;
        const body = document.getElementById('resBody');
        body.innerHTML = "";
        scanResults = [];
        uniqueStrings.clear(); // Azzera la memoria dei duplicati
        log(`Scansione in corso per: ${mode}...`);

        let i = 0x200000;
        let count = 0;

        function doScan() {
            let limit = Math.min(i + 0x50000, rom.length);
            for(; i < limit; i++) {
                if(rom[i] >= 0xBB && rom[i] <= 0xD4) {
                    let s = "", j = i;
                    while(j < rom.length && rom[j] !== 0xFF && s.length < 500) {
                        s += charMap[rom[j]] || '';
                        j++;
                    }

                    // Se il testo √® valido E NON √® mai stato visto prima
                    if(isValidText(s, mode) && !uniqueStrings.has(s)) {
                        uniqueStrings.add(s); // Salvalo nella memoria per non ripeterlo
                        
                        const off = "0x" + i.toString(16).toUpperCase();
                        const bytes = j - i;
                        scanResults.push({o: off, t: s, b: bytes});
                        if(count < 150) {
                            body.insertAdjacentHTML('beforeend', `<tr><td class="hex">${off}</td><td>${bytes}</td><td>${s}</td></tr>`);
                        }
                        count++;
                        i = j;
                    }
                }
            }
            if(i < rom.length - 1) requestAnimationFrame(doScan);
            else log(`Scansione finita. Trovate ${count} stringhe UNICHE.`);
        }
        doScan();
    }

    function exportTxt() {
        if(scanResults.length === 0) return alert("Nessun dato scansionato!");
        let out = "OFFSET | MAX_BYTE | TESTO\n";
        scanResults.forEach(r => out += `${r.o} | ${r.b} | ${r.t}\n`);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([out], {type:'text/plain'}));
        a.download = `Traduzione_${document.getElementById('extractMode').value}.txt`;
        a.click();
    }

    function findFreeSpace(needed) {
        let count = 0;
        for(let i = rom.length - 1; i > 0x800000; i--) {
            if(rom[i] === 0xFF) count++; else count = 0;
            if(count === needed + 10) return i + 5;
        }
        return -1;
    }

    function repoint(oldOff, newOff) {
        let oldPtr = new Uint8Array([oldOff & 0xFF, (oldOff >> 8) & 0xFF, (oldOff >> 16) & 0xFF, 0x08]);
        let newPtr = new Uint8Array([newOff & 0xFF, (newOff >> 8) & 0xFF, (newOff >> 16) & 0xFF, 0x08]);
        let found = 0;
        for(let i = 0; i < rom.length - 4; i++) {
            if(rom[i] === oldPtr[0] && rom[i+1] === oldPtr[1] && rom[i+2] === oldPtr[2] && rom[i+3] === oldPtr[3]) {
                rom.set(newPtr, i);
                found++;
            }
        }
        return found;
    }

    async function applyPatch() {
        const file = document.getElementById('txtFile').files[0];
        if(!file || !rom) return alert("Manca la ROM o il TXT.");
        const lines = (await file.text()).split('\n');
        let d = 0, r = 0;
        log("Patching in corso...");

        lines.forEach(line => {
            if(!line.includes('|') || line.startsWith('OFFSET')) return;
            const [oStr, bStr, text] = line.split('|').map(s => s.trim());
            const oldOff = parseInt(oStr, 16);
            const maxB = parseInt(bStr);

            let bytes = [];
            for(let k=0; k<text.length; k++) {
                if(text[k] === '\\' && text[k+1]) {
                    let code = text[k] + text[k+1];
                    if(invMap[code] !== undefined) { bytes.push(invMap[code]); k++; continue; }
                }
                bytes.push(invMap[text[k]] !== undefined ? invMap[text[k]] : 0x00);
            }
            bytes.push(0xFF); // Terminatore

            if(bytes.length <= maxB + 1) {
                rom.set(bytes, oldOff);
                d++;
            } else {
                let newOff = findFreeSpace(bytes.length);
                if(newOff !== -1) {
                    rom.set(bytes, newOff); 
                    repoint(oldOff, newOff);
                    r++;
                }
            }
        });

        log(`Patch terminata! Parole sovrascritte: ${d} | Spostate: ${r}`);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([rom], {type:'application/octet-stream'}));
        a.download = "Pokemon_Smeraldo_ITA.gba";
        a.click();
    }
</script>
</body>
</html>

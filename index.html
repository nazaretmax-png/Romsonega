<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GBA Translator Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg: #0a0e1a;
            --card: #12182a;
            --accent: #6366f1;
            --text: #e2e8f0;
            --text-dim: #94a3b8;
            --border: #1f2937;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0.75rem;
        }

        /* Header minimalista */
        .header {
            text-align: center;
            padding: 1.5rem 0.75rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--accent);
        }

        .header h1 {
            font-size: clamp(1.25rem, 5vw, 1.75rem);
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.25rem;
        }

        .header p {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        /* Sezioni compatte */
        .section {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.875rem;
            margin-bottom: 0.75rem;
        }

        .section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.625rem;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        /* Input minimalisti */
        input[type="file"], select, button {
            width: 100%;
            padding: 0.625rem 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-size: 0.875rem;
            cursor: pointer;
        }

        button {
            font-weight: 600;
            background: var(--accent);
            border: none;
            margin-top: 0.5rem;
            transition: opacity 0.2s;
        }

        button:hover:not(:disabled) { opacity: 0.85; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .btn-success { background: var(--success); }

        /* Info compatta */
        .info {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg);
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        /* Preview box minimalista */
        .preview {
            margin-top: 0.625rem;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            overflow: hidden;
            background: var(--bg);
        }

        .preview-header {
            background: var(--card);
            padding: 0.5rem 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            font-size: 0.75rem;
        }

        .preview-box {
            height: clamp(250px, 35vh, 400px);
            overflow: auto;
        }

        .preview-box::-webkit-scrollbar { width: 6px; height: 6px; }
        .preview-box::-webkit-scrollbar-track { background: var(--bg); }
        .preview-box::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }

        /* Tabella compatta */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }

        th {
            position: sticky;
            top: 0;
            background: var(--card);
            padding: 0.5rem;
            text-align: left;
            font-weight: 600;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
        }

        td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        tr:hover { background: var(--card); }

        .hex { color: #a78bfa; font-weight: 600; }
        .text-cell { word-break: break-word; }

        /* Progress bar minimalista */
        .progress {
            margin-top: 0.5rem;
            display: none;
        }
        .progress.active { display: block; }

        .progress-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }

        .progress-bar {
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            transition: width 0.2s;
        }

        .progress-status {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 0.25rem;
            font-style: italic;
        }

        /* Log minimalista */
        .log {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.5rem;
            height: 80px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            color: var(--text-dim);
            line-height: 1.4;
        }

        .log::-webkit-scrollbar { width: 4px; }
        .log::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 2px; }

        .log-success { color: var(--success); }
        .log-error { color: var(--danger); }
        .log-warning { color: var(--warning); }

        /* Report compatto */
        .report {
            margin-top: 0.625rem;
            padding: 0.75rem;
            background: var(--bg);
            border-radius: 0.375rem;
            border-left: 3px solid var(--success);
            font-size: 0.75rem;
        }

        .report-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        /* Toast minimalista */
        .toast {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.75rem 1rem;
            font-size: 0.8rem;
            max-width: 90vw;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 1000;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .toast.success { border-left: 3px solid var(--success); }
        .toast.error { border-left: 3px solid var(--danger); }
        .toast.warning { border-left: 3px solid var(--warning); }

        /* Dialog Resume */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        .modal.active { display: flex; }

        .modal-content {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1.25rem;
            max-width: 400px;
            margin: 1rem;
        }

        .modal-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.75rem;
        }

        .modal-text {
            font-size: 0.875rem;
            color: var(--text-dim);
            margin-bottom: 1rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.5rem;
        }

        .modal-actions button {
            margin: 0;
            flex: 1;
        }

        /* Mobile ottimizzato */
        @media (max-width: 640px) {
            .container { padding: 0.5rem; }
            .section { padding: 0.625rem; }
            th, td { padding: 0.375rem; font-size: 0.7rem; }
            .text-cell { max-width: 150px; }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header">
        <h1>ğŸ® GBA Translator Pro</h1>
        <p>Filtri ultra + Autosave intelligente</p>
    </div>

    <!-- ROM -->
    <div class="section">
        <div class="section-title">ğŸ“ ROM</div>
        <input type="file" id="romFile" accept=".gba">
        <div class="info" id="romInfo">â³ Carica un file .gba</div>
    </div>

    <!-- Scansione -->
    <div class="section">
        <div class="section-title">ğŸ” Estrazione</div>
        <select id="extractMode">
            <option value="short">âš”ï¸ Mosse/Oggetti</option>
            <option value="dialogs">ğŸ’¬ Dialoghi</option>
        </select>
        <button onclick="scan()">Scansiona ROM</button>
        
        <div class="progress" id="scanProgress">
            <div class="progress-info">
                <span>Scansione...</span>
                <span id="scanPct">0%</span>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="scanFill"></div></div>
            <div class="progress-status" id="scanStatus"></div>
        </div>
        
        <div class="preview">
            <div class="preview-header">
                <span id="stats">Nessun dato</span>
                <button class="btn-outline" onclick="exportTxt()" style="width:auto;padding:0.375rem 0.75rem;margin:0;font-size:0.7rem">ğŸ’¾ TXT</button>
            </div>
            <div class="preview-box">
                <table>
                    <thead><tr><th>Offset</th><th>Byte</th><th>Testo</th></tr></thead>
                    <tbody id="resBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Patch -->
    <div class="section">
        <div class="section-title">âš¡ Traduzione</div>
        <input type="file" id="txtFile" accept=".txt">
        <button class="btn-success" onclick="patch()" id="patchBtn">Applica Patch</button>
        
        <div class="progress" id="patchProgress">
            <div class="progress-info">
                <span>Patching...</span>
                <span id="patchPct">0%</span>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="patchFill"></div></div>
            <div class="progress-status" id="patchStatus"></div>
        </div>
        
        <div id="patchReport"></div>
    </div>

    <!-- Log -->
    <div class="log" id="log">âœ… Sistema pronto</div>
</div>

<!-- Modal Resume -->
<div class="modal" id="resumeModal">
    <div class="modal-content">
        <div class="modal-title">ğŸ”„ Riprendere patch?</div>
        <div class="modal-text" id="resumeText"></div>
        <div class="modal-actions">
            <button class="btn-outline" onclick="clearResume()">Ricomincia</button>
            <button onclick="resumePatch()">Riprendi</button>
        </div>
    </div>
</div>

<script>
    const charMap = { 0x00: ' ', 0x01: 'Ã€', 0x02: 'Ã', 0x03: 'Ã‚', 0x04: 'Ã‡', 0x05: 'Ãˆ', 0x06: 'Ã‰', 0x07: 'ÃŠ', 0x08: 'Ã‹', 0x09: 'ÃŒ', 0x0B: 'Ã', 0x0C: 'Ã', 0x0D: 'Ã’', 0x0E: 'Ã“', 0x0F: 'Ã”', 0x10: 'Å’', 0x11: 'Ã™', 0x12: 'Ãš', 0x13: 'Ã›', 0x14: 'Å¸', 0x15: 'ÃŸ', 0x16: 'Ã ', 0x17: 'Ã¡', 0x19: 'Ã§', 0x1A: 'Ã¨', 0x1B: 'Ã©', 0x1C: 'Ãª', 0x1D: 'Ã«', 0x1E: 'Ã¬', 0x20: 'Ã®', 0x21: 'Ã¯', 0x22: 'Ã²', 0x23: 'Ã³', 0x24: 'Ã´', 0x25: 'Å“', 0x26: 'Ã¹', 0x27: 'Ãº', 0x28: 'Ã»', 0x29: 'Ã¿', 0x2D: '&', 0x2E: '+', 0xAB: '!', 0xAC: '?', 0xAD: '.', 0xAE: '-', 0xB0: '...', 0xB8: ',', 0xBB: 'A', 0xBC: 'B', 0xBD: 'C', 0xBE: 'D', 0xBF: 'E', 0xC0: 'F', 0xC1: 'G', 0xC2: 'H', 0xC3: 'I', 0xC4: 'J', 0xC5: 'K', 0xC6: 'L', 0xC7: 'M', 0xC8: 'N', 0xC9: 'O', 0xCA: 'P', 0xCB: 'Q', 0xCC: 'R', 0xCD: 'S', 0xCE: 'T', 0xCF: 'U', 0xD0: 'V', 0xD1: 'W', 0xD2: 'X', 0xD3: 'Y', 0xD4: 'Z', 0xD5: 'a', 0xD6: 'b', 0xD7: 'c', 0xD8: 'd', 0xD9: 'e', 0xDA: 'f', 0xDB: 'g', 0xDC: 'h', 0xDD: 'i', 0xDE: 'j', 0xDF: 'k', 0xE0: 'l', 0xE1: 'm', 0xE2: 'n', 0xE3: 'o', 0xE4: 'p', 0xE5: 'q', 0xE6: 'r', 0xE7: 's', 0xE8: 't', 0xE9: 'u', 0xEA: 'v', 0xEB: 'w', 0xEC: 'x', 0xED: 'y', 0xEE: 'z', 0xFA: '\\l', 0xFB: '\\p', 0xFD: '\\v', 0xFE: '\\n' };
    const invMap = Object.fromEntries(Object.entries(charMap).map(([k,v]) => [v, parseInt(k)]));
    
    const validSyllables = ['TI','TA','TO','TE','TU','CA','CO','CHE','CHI','SA','SO','SE','SI','SU','LA','LE','LI','LO','LU','MA','ME','MI','MO','MU','NA','NE','NI','NO','RA','RE','RI','RO','RU','PA','PE','PI','PO','PU','BA','BE','BI','BO','DA','DE','DI','DO','DU','GI','GA','GO','GU','GE','FA','FI','FO','FE','VA','VE','VI','VO','VU','ZA','ZE','ZI','ZO','ZU','ZZA','ZZO','ZZI','TRA','TRE','TRI','TRO','PRE','PRA','PRO','STA','STO','STI','STE','THE','ING','ION','TER','EST','FOR','TIO','ATI','ATE','ICA','ICO','URA','URE','ORA','ORE','ORI','ERA','ERE','ERI','ARO','ARE','ARI','CHA','CHO','CHU','GHA','GHE','GHI','GHO','GLI','GNA','GNE','GNI','GNO','SCA','SCE','SCI','SCO','SCU','SHA','SHE','SHI','SHO','SPE','SPI','SPO','QUA','QUE','QUI','QUO'];
    
    const blockedSounds = ['HA','HE','HI','HO','HU','BA','BE','BI','BO','BU','RA','RE','RI','RO','RU','FO','FA','FU','FE','FI','LA','LE','LI','LO','LU','WA','WE','WI','WO','WU','YA','YE','YI','YO','YU','ZA','ZE','ZI','ZO','ZU','HAHA','HOHO','HEHE','HIHI','BABA','BOBO','RARA','RORO','WAWA','WOWO','YAYA','YOYO','GAGA','GOGO','CATT','MEO','DU','TU','GU','NU','MU','SU','CU','PU'];
    
    const knownWords = ['ITEM','BALL','MEGA','MOVE','HOLD','BACK','EXIT','SURF','FIRE','AQUA','ROCK','LEAF','VOLT','BOLT','STAR','MOON','STONE','WATER','GRASS','TOXIC','STEEL','BURN','FREEZE','SLEEP','DRAGON','GHOST','FAIRY','FIGHT','GROUND','FLYING','POISON','NORMAL','PSYCHIC','SUPER','HYPER','MAX','FULL','HEAL','CURE','FRESH','GUARD','POTION','ELIXIR','ETHER','REVIVE','ESCAPE','ROPE','REPEL','BADGE','CASE','BIKE','COIN','GOOD','GREAT','ULTRA','MASTER','SAFARI','LEVEL','LUXURY','NEST','NET','DIVE','TIMER','REPEAT','PREMIER','DUSK','QUICK','ATTACK','DEFENSE','SPECIAL','SPEED','ACCURACY','EVASION','CRITICAL'];
    
    let rom = null;
    let scanResults = [];
    let uniqueStrings = new Set();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AUTOSAVE SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const AUTOSAVE_KEY = 'gba_patch_state';
    const AUTOSAVE_INTERVAL = 10; // Salva ogni 10 stringhe

    function saveState(idx, stats, lines) {
        const state = {
            timestamp: Date.now(),
            lastIndex: idx,
            stats: stats,
            totalLines: lines.length
        };
        localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(state));
    }

    function loadState() {
        const saved = localStorage.getItem(AUTOSAVE_KEY);
        return saved ? JSON.parse(saved) : null;
    }

    function clearState() {
        localStorage.removeItem(AUTOSAVE_KEY);
    }

    // Check resume al caricamento
    window.addEventListener('load', () => {
        const state = loadState();
        if (state && Date.now() - state.timestamp < 24*60*60*1000) { // 24h
            const elapsed = Math.floor((Date.now() - state.timestamp) / 60000);
            document.getElementById('resumeText').textContent = 
                `Trovato salvataggio da ${elapsed} minuti fa. Processate ${state.lastIndex}/${state.totalLines} stringhe.`;
            document.getElementById('resumeModal').classList.add('active');
        }
    });

    function clearResume() {
        clearState();
        document.getElementById('resumeModal').classList.remove('active');
        toast('Stato cancellato', 'success');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const log = (m, type = 'info') => {
        const l = document.getElementById('log');
        const cls = type === 'success' ? 'log-success' : type === 'error' ? 'log-error' : type === 'warning' ? 'log-warning' : '';
        l.innerHTML += `<span class="${cls}">${m}</span><br>`;
        l.scrollTop = l.scrollHeight;
    };

    const toast = (msg, type = 'success') => {
        const t = document.createElement('div');
        t.className = `toast ${type}`;
        t.textContent = msg;
        document.body.appendChild(t);
        setTimeout(() => t.remove(), 2500);
    };

    document.getElementById('romFile').onchange = function(e) {
        const reader = new FileReader();
        reader.onload = () => {
            rom = new Uint8Array(reader.result);
            const mb = (rom.length / 1024 / 1024).toFixed(1);
            document.getElementById('romInfo').innerHTML = `âœ… ${e.target.files[0].name} (${mb} MB)`;
            log('ROM caricata', 'success');
        };
        reader.readAsArrayBuffer(this.files[0]);
    };

    function countSyllables(str) {
        str = str.toUpperCase();
        let count = 0;
        for (let syl of validSyllables) {
            let pos = 0;
            while ((pos = str.indexOf(syl, pos)) !== -1) {
                count++;
                pos += syl.length;
            }
        }
        return count;
    }

    function isValidText(str, mode) {
        if (!str || str.length < 3) return false;

        if (mode === 'dialogs') {
            if (str.length < 15) return false;
            if (!str.includes('\\n') && !str.includes('\\p') && !str.includes('\\l')) return false;
            if (/(.{2,4})\1{2,}/i.test(str)) return false;
            if (/(.)\1{3,}/i.test(str)) return false;
            if (/([A-Z])\1{2,}/i.test(str)) return false;
            
            const alphaParts = str.match(/[A-Z]+/gi) || [];
            for (let part of alphaParts) {
                if (part.length >= 5) {
                    let isSeq = true;
                    for (let i = 0; i < part.length - 1; i++) {
                        const diff = part.charCodeAt(i + 1) - part.charCodeAt(i);
                        if (diff !== 1 && diff !== 2) { isSeq = false; break; }
                    }
                    if (isSeq) return false;
                }
            }
            
            const accentCount = (str.match(/[Ã€-Ã¿]/g) || []).length;
            const normalLetters = (str.match(/[A-Za-z]/g) || []).length;
            if (normalLetters > 0 && accentCount > normalLetters * 0.15) return false;
            
            if (/[Ã€-Ã¿]{2,}/.test(str)) return false;
            if (/[Ã‹Ãƒ]{2,}/.test(str)) return false;
            if (/Ãƒ[^\s]/.test(str)) return false;
            if (/[Ã…'][^\s]/.test(str)) return false;
            if (/[A-Z]{18,}/.test(str)) return false;
            if (/[BCDFGHJKLMNPQRSTVWXYZ]{5,}/.test(str)) return false;
            
            const singleCaps = str.match(/\b[A-Z]\b/g) || [];
            if (singleCaps.length > 4) return false;
            
            const hasNamePrefix = /^[A-Z][A-Za-z]{1,8}[\s:]/.test(str);
            const isLong = str.length > 35;
            
            const spaceCount = (str.match(/ /g) || []).length;
            const minSpaces = (hasNamePrefix || !isLong) ? 2 : 3;
            if (spaceCount < minSpaces) return false;
            
            const vowelCount = (str.match(/[AEIOUaeiou]/g) || []).length;
            if (normalLetters > 0 && vowelCount < normalLetters * 0.25) return false;
            
            const words = str.split(/[\s\\,!?.]/);
            const realWords = words.filter(w => w.length >= 3 && /^[A-Za-z]+$/.test(w) && countSyllables(w) >= 1);
            const minWords = (hasNamePrefix || !isLong) ? 2 : 3;
            if (realWords.length < minWords) return false;
            
            return true;
        }

        if (mode === 'short') {
            if (str.length < 4 || str.length > 18) return false;
            if (str !== str.toUpperCase()) return false;
            if (str.includes('\\')) return false;
            if (/  +/.test(str) || str.startsWith(' ') || str.endsWith(' ')) return false;
            if (/[^A-Z0-9 \.\!\?\-']/.test(str)) return false;
            
            const cleanStr = str.replace(/[^A-Z]/g, '');
            if (blockedSounds.includes(cleanStr)) return false;
            if (str.split(' ').some(word => blockedSounds.includes(word))) return false;
            
            if (!/[AEIOU]/.test(str)) return false;
            if (/(.)\1{1,}/.test(str.replace(/[^A-Z]/g, ''))) return false;
            
            const vowels = (str.match(/[AEIOU]/g) || []).length;
            const letters = (str.match(/[A-Z]/g) || []).length;
            if (letters > 0 && vowels < letters * 0.30) return false;
            
            if (/[BCDFGHJKLMNPQRSTVWXYZ]{4,}/.test(str)) return false;
            
            for (let i = 0; i < str.length - 2; i++) {
                const c1 = str.charCodeAt(i);
                const c2 = str.charCodeAt(i + 1);
                const c3 = str.charCodeAt(i + 2);
                if (c2 === c1 + 1 && c3 === c2 + 1) return false;
            }
            
            const syllableCount = countSyllables(str);
            if (syllableCount < 2) {
                if (!knownWords.includes(str.replace(/[^A-Z]/g, ''))) return false;
            }
            
            const rareLetters = (str.match(/[QXZJKW]/g) || []).length;
            if (rareLetters > letters * 0.4) return false;
            if (/^[0-9\.\-\s]+$/.test(str)) return false;
            
            return true;
        }
        return false;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SCAN
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function scan() {
        if(!rom) return toast('Carica ROM prima!', 'error');
        
        const mode = document.getElementById('extractMode').value;
        const body = document.getElementById('resBody');
        body.innerHTML = "";
        scanResults = [];
        uniqueStrings.clear();
        
        const wrap = document.getElementById('scanProgress');
        const fill = document.getElementById('scanFill');
        const pct = document.getElementById('scanPct');
        const status = document.getElementById('scanStatus');
        wrap.classList.add('active');
        fill.style.width = '0%';
        
        log(`Scansione ${mode} avviata`);

        const START = 0x200000, END = rom.length;
        let i = START, count = 0, rejected = 0;

        function update() {
            const p = Math.min(100, ((i - START) / (END - START)) * 100);
            fill.style.width = p.toFixed(1) + '%';
            pct.textContent = p.toFixed(0) + '%';
            status.textContent = `0x${i.toString(16).toUpperCase()} â€” ${count} trovate`;
        }

        function doScan() {
            let limit = Math.min(i + 0x50000, END);
            for(; i < limit; i++) {
                if(rom[i] >= 0xBB && rom[i] <= 0xD4) {
                    let s = "", j = i;
                    while(j < rom.length && rom[j] !== 0xFF && s.length < 500) {
                        s += charMap[rom[j]] || '';
                        j++;
                    }

                    if(isValidText(s, mode) && !uniqueStrings.has(s)) {
                        uniqueStrings.add(s);
                        const off = "0x" + i.toString(16).toUpperCase();
                        scanResults.push({o: off, t: s, b: j - i});
                        if(count < 200) {
                            body.insertAdjacentHTML('beforeend', 
                                `<tr><td class="hex">${off}</td><td>${j-i}</td><td class="text-cell">${s}</td></tr>`);
                        }
                        count++;
                        i = j;
                    } else rejected++;
                }
            }
            
            update();
            document.getElementById('stats').textContent = `âœ… ${count} | ğŸš« ${rejected}`;
            
            if(i < END - 1) requestAnimationFrame(doScan);
            else {
                fill.style.width = '100%';
                pct.textContent = '100%';
                status.textContent = `âœ… ${count} stringhe trovate`;
                log(`Completata: ${count} valide`, 'success');
                toast(`${count} stringhe trovate`, 'success');
                setTimeout(() => wrap.classList.remove('active'), 3000);
            }
        }
        doScan();
    }

    function exportTxt() {
        if(!scanResults.length) return toast('Niente da esportare', 'error');
        let out = "OFFSET | MAX_BYTE | TESTO\n";
        scanResults.forEach(r => out += `${r.o} | ${r.b} | ${r.t}\n`);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([out], {type:'text/plain'}));
        a.download = `Trad_${document.getElementById('extractMode').value}_${Date.now()}.txt`;
        a.click();
        log('File esportato', 'success');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PATCH con AUTOSAVE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function textToBytes(text) {
        let bytes = [];
        for (let k = 0; k < text.length; k++) {
            if (text[k] === '\\' && text[k + 1]) {
                let code = text[k] + text[k + 1];
                if (invMap[code] !== undefined) { bytes.push(invMap[code]); k++; continue; }
            }
            bytes.push(invMap[text[k]] !== undefined ? invMap[text[k]] : 0x00);
        }
        bytes.push(0xFF);
        return bytes;
    }

    function findFreeSpace(needed) {
        let count = 0;
        for (let i = rom.length - 1; i > 0x800000; i--) {
            if (rom[i] === 0xFF) count++;
            else count = 0;
            if (count >= needed + 10) return i + 5;
        }
        return -1;
    }

    function createPointer(offset) {
        return new Uint8Array([offset & 0xFF, (offset >> 8) & 0xFF, (offset >> 16) & 0xFF, 0x08]);
    }

    function repointPointers(oldOff, newOff) {
        const oldPtr = createPointer(oldOff);
        const newPtr = createPointer(newOff);
        let found = 0;
        for (let i = 0; i < rom.length - 4; i++) {
            if (rom[i] === oldPtr[0] && rom[i+1] === oldPtr[1] && rom[i+2] === oldPtr[2] && rom[i+3] === oldPtr[3]) {
                rom.set(newPtr, i);
                found++;
            }
        }
        return found;
    }

    async function patch() {
        const file = document.getElementById('txtFile').files[0];
        if (!file || !rom) return toast('ROM o TXT mancante', 'error');

        const btn = document.getElementById('patchBtn');
        btn.disabled = true;

        const wrap = document.getElementById('patchProgress');
        const fill = document.getElementById('patchFill');
        const pct = document.getElementById('patchPct');
        const status = document.getElementById('patchStatus');
        wrap.classList.add('active');
        fill.style.width = '0%';

        const lines = (await file.text()).split('\n').filter(l => l.includes('|') && !l.startsWith('OFFSET'));
        const total = lines.length;
        
        // Check se riprendere
        const saved = loadState();
        let idx = (saved && saved.totalLines === total) ? saved.lastIndex : 0;
        let stats = saved && saved.totalLines === total ? saved.stats : 
            { total: 0, overwritten: 0, repointed: 0, failed: 0, protected: 0 };

        log(`Patch avviata da riga ${idx}/${total}`);
        document.getElementById('patchReport').innerHTML = '';

        function processChunk() {
            const chunkEnd = Math.min(idx + 20, total);

            for (; idx < chunkEnd; idx++) {
                const parts = lines[idx].split('|').map(s => s.trim());
                if (parts.length < 3) continue;

                const [offStr, maxBStr, text] = parts;
                const oldOff = parseInt(offStr, 16);
                const maxB = parseInt(maxBStr);

                if (isNaN(oldOff) || oldOff < 0x200000) {
                    stats.protected++;
                    continue;
                }

                stats.total++;
                const newBytes = textToBytes(text);

                try {
                    if (newBytes.length <= maxB + 1) {
                        rom.set(newBytes, oldOff);
                        const rem = (maxB + 1) - newBytes.length;
                        if (rem > 0) rom.set(new Uint8Array(rem).fill(0xFF), oldOff + newBytes.length);
                        stats.overwritten++;
                    } else {
                        const newOff = findFreeSpace(newBytes.length);
                        if (newOff === -1) {
                            stats.failed++;
                            log(`Spazio mancante: ${offStr}`, 'error');
                            continue;
                        }
                        rom.set(newBytes, newOff);
                        repointPointers(oldOff, newOff);
                        stats.repointed++;
                    }
                } catch(e) {
                    stats.failed++;
                }

                // AUTOSAVE ogni 10 stringhe
                if ((idx + 1) % AUTOSAVE_INTERVAL === 0) {
                    saveState(idx + 1, stats, lines);
                }
            }

            const p = total > 0 ? Math.min(100, (idx / total) * 100) : 100;
            fill.style.width = p.toFixed(1) + '%';
            pct.textContent = p.toFixed(0) + '%';
            status.textContent = `${idx}/${total} â€” âœ…${stats.overwritten} ğŸ”€${stats.repointed} âŒ${stats.failed}`;

            if (idx < total) {
                requestAnimationFrame(processChunk);
            } else {
                // FINE
                clearState();
                fill.style.width = '100%';
                pct.textContent = '100%';
                status.textContent = 'âœ… Completata!';

                document.getElementById('patchReport').innerHTML = `
                    <div class="report">
                        <div class="report-item"><span>Processate</span><strong>${stats.total}</strong></div>
                        <div class="report-item"><span>âœ… In loco</span><strong style="color:var(--success)">${stats.overwritten}</strong></div>
                        <div class="report-item"><span>ğŸ”€ Repoint</span><strong style="color:var(--accent)">${stats.repointed}</strong></div>
                        <div class="report-item"><span>ğŸ›¡ï¸ Protette</span><strong style="color:var(--warning)">${stats.protected}</strong></div>
                        <div class="report-item"><span>âŒ Fallite</span><strong style="color:var(--danger)">${stats.failed}</strong></div>
                    </div>`;

                log(`Patch OK: ${stats.overwritten + stats.repointed}/${stats.total}`, 'success');

                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([rom], {type:'application/octet-stream'}));
                a.download = 'Pokemon_ITA.gba';
                a.click();

                toast('ROM patchata scaricata', 'success');
                btn.disabled = false;
            }
        }

        processChunk();
    }

    function resumePatch() {
        document.getElementById('resumeModal').classList.remove('active');
        // La ROM deve essere caricata e il file TXT riselezionato
        toast('Ricarica ROM e TXT per riprendere', 'warning');
    }
</script>
</body>
</html>
